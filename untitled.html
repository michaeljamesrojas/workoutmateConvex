<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
        <style>
            
        </style>
        <link rel="stylesheet" href="file://C:\Users\micha\AppData\Local\npm-cache\_npx\51def3eb5b6cdb1a\node_modules\repo-to-pdf\html5bp/css/normalize.css">
        <link rel="stylesheet" href="file://C:\Users\micha\AppData\Local\npm-cache\_npx\51def3eb5b6cdb1a\node_modules\repo-to-pdf\html5bp/css/main.css">
        <link rel="stylesheet" href="file://C:\Users\micha\AppData\Local\npm-cache\_npx\51def3eb5b6cdb1a\node_modules\repo-to-pdf\html5bp/css/github-min.css">
        <link rel="stylesheet" href="file://C:\Users\micha\AppData\Local\npm-cache\_npx\51def3eb5b6cdb1a\node_modules\repo-to-pdf\html5bp/css/vs.css">
        <script src="file://C:\Users\micha\AppData\Local\npm-cache\_npx\51def3eb5b6cdb1a\node_modules\repo-to-pdf\html5bp/js/vendor/modernizr-2.6.2.min.js"></script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->

        <!-- Add your site or application content here -->
        <article class="markdown-body"><h1 id=. anchor=true>.</h1>
<h2 id=Contents anchor=true>Contents</h2>
<h4 id=&nbsp;&nbsp;&nbsp;&nbsp;  / anchor=true>      /</h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#convex\authconfig.ts) anchor=true><a href="#convex\authconfig.ts">        |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#convex\authts) anchor=true><a href="#convex\authts">        |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#convex\chatts) anchor=true><a href="#convex\chatts">        |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#convex\eventsts) anchor=true><a href="#convex\eventsts">        |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#convex\READMEmd) anchor=true><a href="#convex\READMEmd">        |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#convex\schemats) anchor=true><a href="#convex\schemats">        |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#convex\videots) anchor=true><a href="#convex\videots">        |- </a></h4>
<h4 id=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  / anchor=true>          /</h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#convex\_generated\apid.ts) anchor=true><a href="#convex_generated\apid.ts">            |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#convex\_generated\apijs) anchor=true><a href="#convex_generated\apijs">            |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#convex\_generated\dataModeld.ts) anchor=true><a href="#convex_generated\dataModeld.ts">            |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#convex\_generated\serverd.ts) anchor=true><a href="#convex_generated\serverd.ts">            |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#convex\_generated\serverjs) anchor=true><a href="#convex_generated\serverjs">            |- </a></h4>
<h4 id=&nbsp;&nbsp;&nbsp;&nbsp;  / anchor=true>      /</h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#dist\indexhtml) anchor=true><a href="#dist\indexhtml">        |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;|- ](#indexhtml) anchor=true><a href="#indexhtml">    |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;|- ](#READMEmd) anchor=true><a href="#READMEmd">    |- </a></h4>
<h4 id=&nbsp;&nbsp;&nbsp;&nbsp;  / anchor=true>      /</h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\Apptsx) anchor=true><a href="#src\Apptsx">        |- </a></h4>
<h4 id=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  / anchor=true>          /</h4>
<h4 id=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  / anchor=true>              /</h4>
<h4 id=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  / anchor=true>          /</h4>
<h4 id=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  / anchor=true>              /</h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\auth\indexts) anchor=true><a href="#src\components\auth\indexts">                |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\auth\Logintsx) anchor=true><a href="#src\components\auth\Logintsx">                |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\auth\OAuthCallbacktsx) anchor=true><a href="#src\components\auth\OAuthCallbacktsx">                |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\auth\ProtectedRoutetsx) anchor=true><a href="#src\components\auth\ProtectedRoutetsx">                |- </a></h4>
<h4 id=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  / anchor=true>              /</h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\calendar\Calendartsx) anchor=true><a href="#src\components\calendar\Calendartsx">                |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\calendar\CustomEventtsx) anchor=true><a href="#src\components\calendar\CustomEventtsx">                |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\calendar\EventModaltsx) anchor=true><a href="#src\components\calendar\EventModaltsx">                |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\calendar\indexts) anchor=true><a href="#src\components\calendar\indexts">                |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\calendar\SessionDetailsModaltsx) anchor=true><a href="#src\components\calendar\SessionDetailsModaltsx">                |- </a></h4>
<h4 id=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  / anchor=true>              /</h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\layout\Headertsx) anchor=true><a href="#src\components\layout\Headertsx">                |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\layout\indexts) anchor=true><a href="#src\components\layout\indexts">                |- </a></h4>
<h4 id=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  / anchor=true>              /</h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\messaging\Chattsx) anchor=true><a href="#src\components\messaging\Chattsx">                |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\messaging\indexts) anchor=true><a href="#src\components\messaging\indexts">                |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\messaging\MessageInputtsx) anchor=true><a href="#src\components\messaging\MessageInputtsx">                |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\messaging\SessionChattsx) anchor=true><a href="#src\components\messaging\SessionChattsx">                |- </a></h4>
<h4 id=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  / anchor=true>              /</h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\session\indexts) anchor=true><a href="#src\components\session\indexts">                |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\session\Sessiontsx) anchor=true><a href="#src\components\session\Sessiontsx">                |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\components\session\VideoCalltsx) anchor=true><a href="#src\components\session\VideoCalltsx">                |- </a></h4>
<h4 id=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  / anchor=true>          /</h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\contexts\AuthContexttsx) anchor=true><a href="#src\contexts\AuthContexttsx">            |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\convexts) anchor=true><a href="#src\convexts">        |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\maintsx) anchor=true><a href="#src\maintsx">        |- </a></h4>
<h4 id=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  / anchor=true>          /</h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\utils\toastts) anchor=true><a href="#src\utils\toastts">            |- </a></h4>
<h4 id=[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- ](#src\vite-envd.ts) anchor=true><a href="#src\vite-envd.ts">        |- </a></h4>
<h4 id=convex\authconfig.ts anchor=true>convex\authconfig.ts</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">providers</span>: [
    {
      <span class="hljs-attr">domain</span>: <span class="hljs-string">&quot;https://smart-griffon-59.clerk.accounts.dev/&quot;</span>,
      <span class="hljs-attr">applicationID</span>: <span class="hljs-string">&quot;convex&quot;</span>,
    },
  ],
};

</code></pre>
<h4 id=convex\authts anchor=true>convex\authts</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { mutation, query } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./_generated/server&quot;</span>;
<span class="hljs-keyword">import</span> { v } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/values&quot;</span>;
<span class="hljs-keyword">import</span> { Id } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./_generated/dataModel&quot;</span>;
<span class="hljs-keyword">import</span> bcrypt <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;bcryptjs&quot;</span>;

<span class="hljs-comment">// We&#x27;ll use synchronous versions of bcrypt functions to avoid setTimeout incompatibility</span>
<span class="hljs-comment">// These are slower but more compatible with Convex&#x27;s limitations</span>

<span class="hljs-comment">// Password management using bcryptjs (synchronous version)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hashPasswordSync</span>(<span class="hljs-params">password: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span> </span>{
  <span class="hljs-comment">// Use 10 rounds (standard secure value)</span>
  <span class="hljs-keyword">const</span> salt = bcrypt.genSaltSync(<span class="hljs-number">10</span>);
  <span class="hljs-keyword">return</span> bcrypt.hashSync(password, salt);
}

<span class="hljs-comment">// Verify password against stored hash (synchronous version)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">verifyPasswordSync</span>(<span class="hljs-params">password: <span class="hljs-built_in">string</span>, hash: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">boolean</span> </span>{
  <span class="hljs-keyword">return</span> bcrypt.compareSync(password, hash);
}

<span class="hljs-comment">/**
 * Authenticate a user with username and password.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> login = mutation({
  <span class="hljs-attr">args</span>: {
    <span class="hljs-attr">username</span>: v.string(),
    <span class="hljs-attr">password</span>: v.string(),
  },
  <span class="hljs-attr">returns</span>: v.object({
    <span class="hljs-attr">userId</span>: v.id(<span class="hljs-string">&quot;users&quot;</span>),
    <span class="hljs-attr">username</span>: v.string(),
  }),
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, args) =&gt; {
    <span class="hljs-comment">// Look for an existing user with this username</span>
    <span class="hljs-keyword">const</span> existingUser = <span class="hljs-keyword">await</span> ctx.db
      .query(<span class="hljs-string">&quot;users&quot;</span>)
      .withIndex(<span class="hljs-string">&quot;by_username&quot;</span>, <span class="hljs-function">(<span class="hljs-params">q</span>) =&gt;</span> q.eq(<span class="hljs-string">&quot;username&quot;</span>, args.username))
      .unique();

    <span class="hljs-comment">// If user exists, verify password</span>
    <span class="hljs-keyword">if</span> (existingUser) {
      <span class="hljs-comment">// If the user was created before passwords were implemented, they may not have a password</span>
      <span class="hljs-keyword">if</span> (!existingUser.password) {
        <span class="hljs-comment">// Update the user with a password</span>
        <span class="hljs-keyword">const</span> passwordHash = hashPasswordSync(args.password);
        <span class="hljs-keyword">await</span> ctx.db.patch(existingUser._id, { <span class="hljs-attr">password</span>: passwordHash });
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">userId</span>: existingUser._id,
          <span class="hljs-attr">username</span>: existingUser.username,
        };
      }

      <span class="hljs-comment">// Verify password</span>
      <span class="hljs-keyword">const</span> isPasswordValid = verifyPasswordSync(
        args.password,
        existingUser.password
      );
      <span class="hljs-keyword">if</span> (!isPasswordValid) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Invalid password&quot;</span>);
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">userId</span>: existingUser._id,
        <span class="hljs-attr">username</span>: existingUser.username,
      };
    }

    <span class="hljs-comment">// If user doesn&#x27;t exist, throw an error instead of creating a new account</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
      <span class="hljs-string">&quot;Account not found. Please register before attempting to sign in.&quot;</span>
    );
  },
});

<span class="hljs-comment">/**
 * Register a new user
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> register = mutation({
  <span class="hljs-attr">args</span>: {
    <span class="hljs-attr">username</span>: v.string(),
    <span class="hljs-attr">password</span>: v.string(),
  },
  <span class="hljs-attr">returns</span>: v.object({
    <span class="hljs-attr">userId</span>: v.id(<span class="hljs-string">&quot;users&quot;</span>),
    <span class="hljs-attr">username</span>: v.string(),
  }),
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, args) =&gt; {
    <span class="hljs-comment">// Check if username already exists</span>
    <span class="hljs-keyword">const</span> existingUser = <span class="hljs-keyword">await</span> ctx.db
      .query(<span class="hljs-string">&quot;users&quot;</span>)
      .withIndex(<span class="hljs-string">&quot;by_username&quot;</span>, <span class="hljs-function">(<span class="hljs-params">q</span>) =&gt;</span> q.eq(<span class="hljs-string">&quot;username&quot;</span>, args.username))
      .unique();

    <span class="hljs-keyword">if</span> (existingUser) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Username already exists&quot;</span>);
    }

    <span class="hljs-comment">// Create a new user</span>
    <span class="hljs-keyword">const</span> passwordHash = hashPasswordSync(args.password);
    <span class="hljs-keyword">const</span> userId = <span class="hljs-keyword">await</span> ctx.db.insert(<span class="hljs-string">&quot;users&quot;</span>, {
      <span class="hljs-attr">username</span>: args.username,
      <span class="hljs-attr">password</span>: passwordHash,
      <span class="hljs-attr">createdAt</span>: <span class="hljs-built_in">Date</span>.now(),
    });

    <span class="hljs-keyword">return</span> {
      userId,
      <span class="hljs-attr">username</span>: args.username,
    };
  },
});

<span class="hljs-comment">/**
 * Get the current user if logged in
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getUser = query({
  <span class="hljs-attr">args</span>: {
    <span class="hljs-attr">userId</span>: v.optional(v.id(<span class="hljs-string">&quot;users&quot;</span>)),
  },
  <span class="hljs-attr">returns</span>: v.union(
    v.object({
      <span class="hljs-attr">userId</span>: v.id(<span class="hljs-string">&quot;users&quot;</span>),
      <span class="hljs-attr">username</span>: v.string(),
    }),
    v.null()
  ),
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, args) =&gt; {
    <span class="hljs-keyword">if</span> (!args.userId) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> ctx.db.get(args.userId);
    <span class="hljs-keyword">if</span> (!user) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">userId</span>: user._id,
      <span class="hljs-attr">username</span>: user.username,
    };
  },
});

<span class="hljs-comment">/**
 * Get or create a user with Clerk authentication
 * This function is called when a user signs in with Google via Clerk
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getUserFromClerk = mutation({
  <span class="hljs-attr">args</span>: {
    <span class="hljs-attr">clerkId</span>: v.string(),
    <span class="hljs-attr">username</span>: v.string(),
  },
  <span class="hljs-attr">returns</span>: v.object({
    <span class="hljs-attr">userId</span>: v.id(<span class="hljs-string">&quot;users&quot;</span>),
    <span class="hljs-attr">username</span>: v.string(),
  }),
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, args) =&gt; {
    <span class="hljs-comment">// Check if user with this Clerk ID already exists</span>
    <span class="hljs-keyword">const</span> existingUser = <span class="hljs-keyword">await</span> ctx.db
      .query(<span class="hljs-string">&quot;users&quot;</span>)
      .withIndex(<span class="hljs-string">&quot;by_clerkId&quot;</span>, <span class="hljs-function">(<span class="hljs-params">q</span>) =&gt;</span> q.eq(<span class="hljs-string">&quot;clerkId&quot;</span>, args.clerkId))
      .unique();

    <span class="hljs-keyword">if</span> (existingUser) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">userId</span>: existingUser._id,
        <span class="hljs-attr">username</span>: existingUser.username,
      };
    }

    <span class="hljs-comment">// Otherwise, create a new user</span>
    <span class="hljs-keyword">const</span> userId = <span class="hljs-keyword">await</span> ctx.db.insert(<span class="hljs-string">&quot;users&quot;</span>, {
      <span class="hljs-attr">username</span>: args.username,
      <span class="hljs-attr">clerkId</span>: args.clerkId,
      <span class="hljs-attr">createdAt</span>: <span class="hljs-built_in">Date</span>.now(),
    });

    <span class="hljs-keyword">return</span> {
      userId,
      <span class="hljs-attr">username</span>: args.username,
    };
  },
});

</code></pre>
<h4 id=convex\chatts anchor=true>convex\chatts</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { internalAction, mutation, query } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./_generated/server&quot;</span>;
<span class="hljs-keyword">import</span> { v } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/values&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> sendMessage = mutation({
  <span class="hljs-attr">args</span>: {
    <span class="hljs-attr">user</span>: v.string(),
    <span class="hljs-attr">body</span>: v.string(),
    <span class="hljs-attr">sessionId</span>: v.optional(v.string()),
  },
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, args) =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;This TypeScript function is running on the server.&quot;</span>);
    <span class="hljs-keyword">await</span> ctx.db.insert(<span class="hljs-string">&quot;messages&quot;</span>, {
      <span class="hljs-attr">user</span>: args.user,
      <span class="hljs-attr">body</span>: args.body,
      <span class="hljs-attr">sessionId</span>: args.sessionId,
    });
  },
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getMessages = query({
  <span class="hljs-attr">args</span>: {},
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx) =&gt; {
    <span class="hljs-keyword">const</span> messages = <span class="hljs-keyword">await</span> ctx.db.query(<span class="hljs-string">&quot;messages&quot;</span>).order(<span class="hljs-string">&quot;desc&quot;</span>).take(<span class="hljs-number">50</span>);

    <span class="hljs-keyword">return</span> messages.reverse();
  },
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getSessionMessages = query({
  <span class="hljs-attr">args</span>: {
    <span class="hljs-attr">sessionId</span>: v.string(),
  },
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, args) =&gt; {
    <span class="hljs-keyword">if</span> (!args.sessionId) {
      <span class="hljs-keyword">return</span> [];
    }

    <span class="hljs-keyword">const</span> messages = <span class="hljs-keyword">await</span> ctx.db
      .query(<span class="hljs-string">&quot;messages&quot;</span>)
      .withIndex(<span class="hljs-string">&quot;by_sessionId&quot;</span>, <span class="hljs-function">(<span class="hljs-params">q</span>) =&gt;</span> q.eq(<span class="hljs-string">&quot;sessionId&quot;</span>, args.sessionId))
      .order(<span class="hljs-string">&quot;desc&quot;</span>)
      .take(<span class="hljs-number">100</span>);

    <span class="hljs-keyword">return</span> messages.reverse();
  },
});

<span class="hljs-comment">// export const getWikipediaSummary = internalAction({</span>
<span class="hljs-comment">//   args: { topic: v.string() },</span>
<span class="hljs-comment">//   handler: async (ctx, args) =&gt; {</span>
<span class="hljs-comment">//     const response = await fetch(</span>
<span class="hljs-comment">//       &quot;https://en.wikipedia.org/w/api.php?format=json&amp;action=query&amp;prop=extracts&amp;exintro&amp;explaintext&amp;redirects=1&amp;titles=&quot; +</span>
<span class="hljs-comment">//         args.topic,</span>
<span class="hljs-comment">//     );</span>

<span class="hljs-comment">//     return getSummaryFromJSON(await response.json());</span>
<span class="hljs-comment">//   },</span>
<span class="hljs-comment">// });</span>

<span class="hljs-comment">// function getSummaryFromJSON(data: any) {</span>
<span class="hljs-comment">//   const firstPageId = Object.keys(data.query.pages)[0];</span>
<span class="hljs-comment">//   return data.query.pages[firstPageId].extract;</span>
<span class="hljs-comment">// }</span>

</code></pre>
<h4 id=convex\eventsts anchor=true>convex\eventsts</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { v } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/values&quot;</span>;
<span class="hljs-keyword">import</span> { mutation, query } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./_generated/server&quot;</span>;

<span class="hljs-comment">// Create a new event</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> create = mutation({
  <span class="hljs-attr">args</span>: {
    <span class="hljs-attr">userId</span>: v.string(),
    <span class="hljs-attr">title</span>: v.string(),
    <span class="hljs-attr">start</span>: v.string(),
    <span class="hljs-attr">end</span>: v.optional(v.string()),
  },
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, args) =&gt; {
    <span class="hljs-comment">// Validate that the start date is not in the past</span>
    <span class="hljs-keyword">const</span> startDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(args.start);
    <span class="hljs-keyword">const</span> currentDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
    
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Create Session - Validation:&quot;</span>, {
      startDate,
      currentDate,
      <span class="hljs-attr">isPastDate</span>: startDate &lt; currentDate,
      <span class="hljs-attr">userId</span>: args.userId,
      <span class="hljs-attr">title</span>: args.title
    });
    
    <span class="hljs-keyword">if</span> (startDate &lt; currentDate) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Create Session - Rejected: Past date detected&quot;</span>);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Cannot create session with a past date. Please select a future date.&quot;</span>);
    }

    <span class="hljs-comment">// Check for overlapping sessions for the same user</span>
    <span class="hljs-keyword">const</span> userEvents = <span class="hljs-keyword">await</span> ctx.db
      .query(<span class="hljs-string">&quot;events&quot;</span>)
      .withIndex(<span class="hljs-string">&quot;by_userId&quot;</span>, <span class="hljs-function">(<span class="hljs-params">q</span>) =&gt;</span> q.eq(<span class="hljs-string">&quot;userId&quot;</span>, args.userId))
      .collect();
    
    <span class="hljs-comment">// Parse the new session&#x27;s time range</span>
    <span class="hljs-keyword">const</span> newStart = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(args.start).getTime();
    <span class="hljs-keyword">const</span> newEnd = args.end ? <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(args.end).getTime() : newStart + <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>; <span class="hljs-comment">// Default to 1 hour if no end provided</span>
    
    <span class="hljs-comment">// Check each existing event for overlap</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> event <span class="hljs-keyword">of</span> userEvents) {
      <span class="hljs-keyword">const</span> existingStart = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(event.start).getTime();
      <span class="hljs-keyword">const</span> existingEnd = event.end ? <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(event.end).getTime() : existingStart + <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
      
      <span class="hljs-comment">// Check for overlap: </span>
      <span class="hljs-comment">// New event starts during existing event OR </span>
      <span class="hljs-comment">// New event ends during existing event OR</span>
      <span class="hljs-comment">// New event completely contains existing event</span>
      <span class="hljs-keyword">const</span> overlap = (newStart &gt;= existingStart &amp;&amp; newStart &lt; existingEnd) || 
                      (newEnd &gt; existingStart &amp;&amp; newEnd &lt;= existingEnd) ||
                      (newStart &lt;= existingStart &amp;&amp; newEnd &gt;= existingEnd);
      
      <span class="hljs-keyword">if</span> (overlap) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Create Session - Rejected: Overlapping session detected&quot;</span>, {
          <span class="hljs-attr">newSession</span>: { <span class="hljs-attr">start</span>: args.start, <span class="hljs-attr">end</span>: args.end },
          <span class="hljs-attr">existingSession</span>: { <span class="hljs-attr">start</span>: event.start, <span class="hljs-attr">end</span>: event.end, <span class="hljs-attr">title</span>: event.title }
        });
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Cannot create overlapping sessions. You already have a session scheduled during this time.&quot;</span>);
      }
    }

    <span class="hljs-keyword">const</span> eventId = <span class="hljs-keyword">await</span> ctx.db.insert(<span class="hljs-string">&quot;events&quot;</span>, {
      <span class="hljs-attr">userId</span>: args.userId,
      <span class="hljs-attr">title</span>: args.title,
      <span class="hljs-attr">start</span>: args.start,
      <span class="hljs-attr">end</span>: args.end,
      <span class="hljs-attr">createdAt</span>: <span class="hljs-built_in">Date</span>.now(),
    });
    
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Create Session - Success:&quot;</span>, {
      eventId,
      <span class="hljs-attr">title</span>: args.title,
    });

    <span class="hljs-keyword">return</span> eventId;
  },
});

<span class="hljs-comment">// Get all events for a user</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getByUserId = query({
  <span class="hljs-attr">args</span>: {
    <span class="hljs-attr">userId</span>: v.string(),
  },
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, args) =&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> ctx.db
      .query(<span class="hljs-string">&quot;events&quot;</span>)
      .withIndex(<span class="hljs-string">&quot;by_userId&quot;</span>, <span class="hljs-function">(<span class="hljs-params">q</span>) =&gt;</span> q.eq(<span class="hljs-string">&quot;userId&quot;</span>, args.userId))
      .collect();
  },
});

<span class="hljs-comment">// Get all events from all users with creator username</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getAllEvents = query({
  <span class="hljs-attr">args</span>: {},
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx) =&gt; {
    <span class="hljs-comment">// First, get all users and create a userId -&gt; username map</span>
    <span class="hljs-keyword">const</span> allUsers = <span class="hljs-keyword">await</span> ctx.db.query(<span class="hljs-string">&quot;users&quot;</span>).collect();
    <span class="hljs-keyword">const</span> userMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

    <span class="hljs-comment">// Create a map of user IDs to usernames</span>
    allUsers.forEach(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> {
      <span class="hljs-comment">// Try adding both _id and clerkId to the map</span>
      userMap.set(user._id, user.username);
      <span class="hljs-keyword">if</span> (user.clerkId) {
        userMap.set(user.clerkId, user.username);
      }
    });

    <span class="hljs-comment">// Get all events</span>
    <span class="hljs-keyword">const</span> events = <span class="hljs-keyword">await</span> ctx.db.query(<span class="hljs-string">&quot;events&quot;</span>).collect();

    <span class="hljs-comment">// Add username to each event</span>
    <span class="hljs-keyword">const</span> eventsWithUserInfo = events.map(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> {
        ...event,
        <span class="hljs-attr">creatorName</span>: userMap.get(event.userId) || <span class="hljs-string">&quot;Unknown User&quot;</span>,
      };
    });

    <span class="hljs-keyword">return</span> eventsWithUserInfo;
  },
});

<span class="hljs-comment">// Update an existing event</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> update = mutation({
  <span class="hljs-attr">args</span>: {
    <span class="hljs-attr">id</span>: v.id(<span class="hljs-string">&quot;events&quot;</span>),
    <span class="hljs-attr">title</span>: v.string(),
    <span class="hljs-attr">start</span>: v.string(),
    <span class="hljs-attr">end</span>: v.optional(v.string()),
  },
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, args) =&gt; {
    <span class="hljs-keyword">const</span> event = <span class="hljs-keyword">await</span> ctx.db.get(args.id);
    <span class="hljs-keyword">if</span> (!event) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Update Session - Failed: Event not found&quot;</span>, args.id);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Event not found&quot;</span>);
    }

    <span class="hljs-comment">// Validate that the start date is not in the past</span>
    <span class="hljs-keyword">const</span> startDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(args.start);
    <span class="hljs-keyword">const</span> currentDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
    
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Update Session - Validation:&quot;</span>, {
      <span class="hljs-attr">eventId</span>: args.id,
      startDate,
      currentDate,
      <span class="hljs-attr">isPastDate</span>: startDate &lt; currentDate,
      <span class="hljs-attr">title</span>: args.title
    });
    
    <span class="hljs-keyword">if</span> (startDate &lt; currentDate) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Update Session - Rejected: Past date detected&quot;</span>);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Cannot update session to a past date. Please select a future date.&quot;</span>);
    }

    <span class="hljs-comment">// Check for overlapping sessions for the same user</span>
    <span class="hljs-keyword">const</span> userEvents = <span class="hljs-keyword">await</span> ctx.db
      .query(<span class="hljs-string">&quot;events&quot;</span>)
      .withIndex(<span class="hljs-string">&quot;by_userId&quot;</span>, <span class="hljs-function">(<span class="hljs-params">q</span>) =&gt;</span> q.eq(<span class="hljs-string">&quot;userId&quot;</span>, event.userId))
      .collect();
    
    <span class="hljs-comment">// Parse the updated session&#x27;s time range</span>
    <span class="hljs-keyword">const</span> newStart = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(args.start).getTime();
    <span class="hljs-keyword">const</span> newEnd = args.end ? <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(args.end).getTime() : newStart + <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
    
    <span class="hljs-comment">// Check each existing event for overlap</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> existingEvent <span class="hljs-keyword">of</span> userEvents) {
      <span class="hljs-comment">// Skip checking against the event being updated</span>
      <span class="hljs-keyword">if</span> (existingEvent._id === args.id) <span class="hljs-keyword">continue</span>;
      
      <span class="hljs-keyword">const</span> existingStart = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(existingEvent.start).getTime();
      <span class="hljs-keyword">const</span> existingEnd = existingEvent.end ? <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(existingEvent.end).getTime() : existingStart + <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
      
      <span class="hljs-comment">// Check for overlap</span>
      <span class="hljs-keyword">const</span> overlap = (newStart &gt;= existingStart &amp;&amp; newStart &lt; existingEnd) || 
                      (newEnd &gt; existingStart &amp;&amp; newEnd &lt;= existingEnd) ||
                      (newStart &lt;= existingStart &amp;&amp; newEnd &gt;= existingEnd);
      
      <span class="hljs-keyword">if</span> (overlap) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Update Session - Rejected: Overlapping session detected&quot;</span>, {
          <span class="hljs-attr">updatedSession</span>: { <span class="hljs-attr">id</span>: args.id, <span class="hljs-attr">start</span>: args.start, <span class="hljs-attr">end</span>: args.end },
          <span class="hljs-attr">existingSession</span>: { <span class="hljs-attr">id</span>: existingEvent._id, <span class="hljs-attr">start</span>: existingEvent.start, <span class="hljs-attr">end</span>: existingEvent.end, <span class="hljs-attr">title</span>: existingEvent.title }
        });
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Cannot create overlapping sessions. You already have a session scheduled during this time.&quot;</span>);
      }
    }

    <span class="hljs-keyword">await</span> ctx.db.patch(args.id, {
      <span class="hljs-attr">title</span>: args.title,
      <span class="hljs-attr">start</span>: args.start,
      <span class="hljs-attr">end</span>: args.end,
    });
    
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Update Session - Success:&quot;</span>, {
      <span class="hljs-attr">eventId</span>: args.id,
      <span class="hljs-attr">title</span>: args.title,
    });

    <span class="hljs-keyword">return</span> args.id;
  },
});

<span class="hljs-comment">// Mutation to join a session (add user to participant list)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> joinSession = mutation({
  <span class="hljs-attr">args</span>: { <span class="hljs-attr">eventId</span>: v.id(<span class="hljs-string">&quot;events&quot;</span>) },
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, args) =&gt; {
    <span class="hljs-keyword">const</span> identity = <span class="hljs-keyword">await</span> ctx.auth.getUserIdentity();
    <span class="hljs-keyword">if</span> (!identity) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;User must be authenticated to join a session.&quot;</span>);
    }
    <span class="hljs-keyword">const</span> userId = identity.subject; <span class="hljs-comment">// Use the subject as the stable user ID</span>

    <span class="hljs-keyword">const</span> event = <span class="hljs-keyword">await</span> ctx.db.get(args.eventId);
    <span class="hljs-keyword">if</span> (!event) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Event not found.&quot;</span>);
    }

    <span class="hljs-comment">// Ensure participantIds array exists and add user if not already present</span>
    <span class="hljs-keyword">const</span> currentParticipants = event.participantIds || [];
    <span class="hljs-keyword">if</span> (!currentParticipants.includes(userId)) {
      <span class="hljs-keyword">const</span> updatedParticipants = [...currentParticipants, userId];
      <span class="hljs-keyword">await</span> ctx.db.patch(args.eventId, { <span class="hljs-attr">participantIds</span>: updatedParticipants });
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`User <span class="hljs-subst">${userId}</span> joined event <span class="hljs-subst">${args.eventId}</span>`</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`User <span class="hljs-subst">${userId}</span> is already in event <span class="hljs-subst">${args.eventId}</span>`</span>);
    }
  },
});

<span class="hljs-comment">// Get a single event by ID</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getEventById = query({
  <span class="hljs-attr">args</span>: { <span class="hljs-attr">id</span>: v.string() }, <span class="hljs-comment">// Changed to string, will validate if it&#x27;s an ID format</span>
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, args) =&gt; {
    <span class="hljs-keyword">if</span> (!args.id) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;getEventById - No ID provided&quot;</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// First, get all users and create a userId -&gt; username map</span>
      <span class="hljs-keyword">const</span> allUsers = <span class="hljs-keyword">await</span> ctx.db.query(<span class="hljs-string">&quot;users&quot;</span>).collect();
      <span class="hljs-keyword">const</span> userMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

      <span class="hljs-comment">// Create a map of user IDs to usernames</span>
      allUsers.forEach(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> {
        <span class="hljs-comment">// Try adding both _id and clerkId to the map</span>
        userMap.set(user._id, user.username);
        <span class="hljs-keyword">if</span> (user.clerkId) {
          userMap.set(user.clerkId, user.username);
        }
      });

      <span class="hljs-comment">// Get the event by ID</span>
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> eventId = args.id <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>; <span class="hljs-comment">// Convert to any to avoid type issues</span>
        <span class="hljs-keyword">const</span> event = <span class="hljs-keyword">await</span> ctx.db.get(eventId);

        <span class="hljs-keyword">if</span> (!event) {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;getEventById - Event not found&quot;</span>, eventId);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-comment">// Check if it&#x27;s actually an event by looking for event-specific fields</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-keyword">in</span> event &amp;&amp; <span class="hljs-string">&quot;start&quot;</span> <span class="hljs-keyword">in</span> event) {
          <span class="hljs-comment">// Log session timing information for debugging</span>
          <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
          <span class="hljs-keyword">const</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(event.start);
          <span class="hljs-keyword">const</span> endTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(event.end || event.start);
          <span class="hljs-keyword">const</span> timeUntilStart = startTime.getTime() - now.getTime();
          
          <span class="hljs-comment">// Early join threshold - 10 minutes</span>
          <span class="hljs-keyword">const</span> earlyJoinThreshold = <span class="hljs-number">10</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>; <span class="hljs-comment">// 10 minutes in milliseconds</span>
          <span class="hljs-keyword">const</span> canEarlyJoin = timeUntilStart &gt; <span class="hljs-number">0</span> &amp;&amp; timeUntilStart &lt;= earlyJoinThreshold;
          
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Session timing info:&quot;</span>, {
            <span class="hljs-attr">eventId</span>: event._id,
            <span class="hljs-attr">title</span>: event.title,
            <span class="hljs-attr">startTime</span>: startTime.toISOString(),
            <span class="hljs-attr">endTime</span>: endTime.toISOString(),
            <span class="hljs-attr">currentTime</span>: now.toISOString(),
            timeUntilStart,
            <span class="hljs-attr">minutesUntilStart</span>: <span class="hljs-built_in">Math</span>.ceil(timeUntilStart / (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span>)),
            <span class="hljs-attr">isActive</span>: now &gt;= startTime &amp;&amp; now &lt;= endTime,
            canEarlyJoin,
            <span class="hljs-attr">isPast</span>: now &gt; endTime
          });

          <span class="hljs-comment">// Add creator name to the event</span>
          <span class="hljs-keyword">return</span> {
            ...event,
            <span class="hljs-attr">creatorName</span>: userMap.get(event.userId) || <span class="hljs-string">&quot;Unknown User&quot;</span>,
          };
        }

        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Decide if we should return null or the document if it&#x27;s not an event?</span>
        <span class="hljs-comment">// Returning the document might be confusing if the caller expects an Event type.</span>
        <span class="hljs-comment">// Returning null might be safer if the caller specifically expects an event.</span>
        <span class="hljs-comment">// For now, let&#x27;s assume the caller might handle non-event docs, but log a warning.</span>
        <span class="hljs-keyword">else</span> {
             <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`Document found for ID <span class="hljs-subst">${eventId}</span> is not an event document. Type might be <span class="hljs-subst">${<span class="hljs-keyword">typeof</span> event}</span>.`</span>);
        }

        <span class="hljs-keyword">return</span> event; <span class="hljs-comment">// Return the raw document</span>
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Error getting event:&quot;</span>, error);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Error fetching event by ID:&quot;</span>, error);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  },
});

<span class="hljs-comment">// Delete an event by ID</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> deleteEvent = mutation({
  <span class="hljs-attr">args</span>: {
    <span class="hljs-attr">id</span>: v.id(<span class="hljs-string">&quot;events&quot;</span>),
  },
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, args) =&gt; {
    <span class="hljs-keyword">const</span> event = <span class="hljs-keyword">await</span> ctx.db.get(args.id);
    <span class="hljs-keyword">if</span> (!event) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Delete Event - Failed: Event not found&quot;</span>, args.id);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Event not found&quot;</span>);
    }

    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Delete Event - Deleting:&quot;</span>, {
      <span class="hljs-attr">eventId</span>: args.id,
      <span class="hljs-attr">title</span>: event.title,
    });

    <span class="hljs-keyword">await</span> ctx.db.delete(args.id);
    
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Delete Event - Success: Event deleted&quot;</span>, args.id);
    <span class="hljs-keyword">return</span> args.id;
  },
});

</code></pre>
<h4 id=convex\READMEmd anchor=true>convex\READMEmd</h4>
<p><a href="#Contents">to top</a></p>
<h1 id=Welcome to your Convex functions directory! anchor=true>Welcome to your Convex functions directory!</h1>
<p>Write your Convex functions here.<br>
See https://docs.convex.dev/functions for more.</p>
<p>A query function that takes two arguments looks like:</p>
<pre><code class="language-ts"><span class="hljs-comment">// functions.js</span>
<span class="hljs-keyword">import</span> { query } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./_generated/server&quot;</span>;
<span class="hljs-keyword">import</span> { v } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/values&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> myQueryFunction = query({
  <span class="hljs-comment">// Validators for arguments.</span>
  <span class="hljs-attr">args</span>: {
    <span class="hljs-attr">first</span>: v.number(),
    <span class="hljs-attr">second</span>: v.string(),
  },

  <span class="hljs-comment">// Function implementation.</span>
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, args) =&gt; {
    <span class="hljs-comment">// Read the database as many times as you need here.</span>
    <span class="hljs-comment">// See https://docs.convex.dev/database/reading-data.</span>
    <span class="hljs-keyword">const</span> documents = <span class="hljs-keyword">await</span> ctx.db.query(<span class="hljs-string">&quot;tablename&quot;</span>).collect();

    <span class="hljs-comment">// Arguments passed from the client are properties of the args object.</span>
    <span class="hljs-built_in">console</span>.log(args.first, args.second);

    <span class="hljs-comment">// Write arbitrary JavaScript here: filter, aggregate, build derived data,</span>
    <span class="hljs-comment">// remove non-public properties, or create new objects.</span>
    <span class="hljs-keyword">return</span> documents;
  },
});
</code></pre>
<p>Using this query function in a React component looks like:</p>
<pre><code class="language-ts"><span class="hljs-keyword">const</span> data = useQuery(api.functions.myQueryFunction, {
  <span class="hljs-attr">first</span>: <span class="hljs-number">10</span>,
  <span class="hljs-attr">second</span>: <span class="hljs-string">&quot;hello&quot;</span>,
});
</code></pre>
<p>A mutation function looks like:</p>
<pre><code class="language-ts"><span class="hljs-comment">// functions.js</span>
<span class="hljs-keyword">import</span> { mutation } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./_generated/server&quot;</span>;
<span class="hljs-keyword">import</span> { v } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/values&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> myMutationFunction = mutation({
  <span class="hljs-comment">// Validators for arguments.</span>
  <span class="hljs-attr">args</span>: {
    <span class="hljs-attr">first</span>: v.string(),
    <span class="hljs-attr">second</span>: v.string(),
  },

  <span class="hljs-comment">// Function implementation.</span>
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, args) =&gt; {
    <span class="hljs-comment">// Insert or modify documents in the database here.</span>
    <span class="hljs-comment">// Mutations can also read from the database like queries.</span>
    <span class="hljs-comment">// See https://docs.convex.dev/database/writing-data.</span>
    <span class="hljs-keyword">const</span> message = { <span class="hljs-attr">body</span>: args.first, <span class="hljs-attr">author</span>: args.second };
    <span class="hljs-keyword">const</span> id = <span class="hljs-keyword">await</span> ctx.db.insert(<span class="hljs-string">&quot;messages&quot;</span>, message);

    <span class="hljs-comment">// Optionally, return a value from your mutation.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> ctx.db.get(id);
  },
});
</code></pre>
<p>Using this mutation function in a React component looks like:</p>
<pre><code class="language-ts"><span class="hljs-keyword">const</span> mutation = useMutation(api.functions.myMutationFunction);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleButtonPress</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// fire and forget, the most common way to use mutations</span>
  mutation({ <span class="hljs-attr">first</span>: <span class="hljs-string">&quot;Hello!&quot;</span>, <span class="hljs-attr">second</span>: <span class="hljs-string">&quot;me&quot;</span> });
  <span class="hljs-comment">// OR</span>
  <span class="hljs-comment">// use the result once the mutation has completed</span>
  mutation({ <span class="hljs-attr">first</span>: <span class="hljs-string">&quot;Hello!&quot;</span>, <span class="hljs-attr">second</span>: <span class="hljs-string">&quot;me&quot;</span> }).then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span>
    <span class="hljs-built_in">console</span>.log(result),
  );
}
</code></pre>
<p>Use the Convex CLI to push your functions to a deployment. See everything<br>
the Convex CLI can do by running <code>npx convex -h</code> in your project root<br>
directory. To learn more, launch the docs with <code>npx convex docs</code>.</p>
<h4 id=convex\schemats anchor=true>convex\schemats</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { defineSchema, defineTable } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/server&quot;</span>;
<span class="hljs-keyword">import</span> { v } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/values&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineSchema({
  <span class="hljs-attr">messages</span>: defineTable({
    <span class="hljs-attr">user</span>: v.string(),
    <span class="hljs-attr">body</span>: v.string(),
    <span class="hljs-attr">sessionId</span>: v.optional(v.string()),
  }).index(<span class="hljs-string">&quot;by_sessionId&quot;</span>, [<span class="hljs-string">&quot;sessionId&quot;</span>]),

  <span class="hljs-attr">users</span>: defineTable({
    <span class="hljs-attr">username</span>: v.string(),
    <span class="hljs-attr">password</span>: v.optional(v.string()),
    <span class="hljs-attr">createdAt</span>: v.number(),
    <span class="hljs-attr">clerkId</span>: v.optional(v.string()),
  })
    .index(<span class="hljs-string">&quot;by_username&quot;</span>, [<span class="hljs-string">&quot;username&quot;</span>])
    .index(<span class="hljs-string">&quot;by_clerkId&quot;</span>, [<span class="hljs-string">&quot;clerkId&quot;</span>]),

  <span class="hljs-attr">events</span>: defineTable({
    <span class="hljs-attr">userId</span>: v.string(),
    <span class="hljs-attr">title</span>: v.string(),
    <span class="hljs-attr">start</span>: v.string(), <span class="hljs-comment">// Store start time as ISO string</span>
    <span class="hljs-attr">end</span>: v.optional(v.string()), <span class="hljs-comment">// Store end time as ISO string, optional</span>
    <span class="hljs-attr">createdAt</span>: v.number(),
    <span class="hljs-attr">participantIds</span>: v.optional(v.array(v.string())), <span class="hljs-comment">// Array of user IDs in the session</span>
  })
    .index(<span class="hljs-string">&quot;by_userId&quot;</span>, [<span class="hljs-string">&quot;userId&quot;</span>])
    .index(<span class="hljs-string">&quot;by_userId_start&quot;</span>, [<span class="hljs-string">&quot;userId&quot;</span>, <span class="hljs-string">&quot;start&quot;</span>]),

  <span class="hljs-comment">// New table for WebRTC signaling</span>
  <span class="hljs-attr">videoSignals</span>: defineTable({
    <span class="hljs-attr">sessionId</span>: v.string(),      <span class="hljs-comment">// ID of the session the signal belongs to</span>
    <span class="hljs-attr">userId</span>: v.string(),         <span class="hljs-comment">// ID of the user sending the signal</span>
    <span class="hljs-attr">targetUserId</span>: v.string(),   <span class="hljs-comment">// ID of the user the signal is intended for</span>
    <span class="hljs-attr">type</span>: v.union(             <span class="hljs-comment">// Type of signal</span>
      v.literal(<span class="hljs-string">&quot;offer&quot;</span>),
      v.literal(<span class="hljs-string">&quot;answer&quot;</span>),
      v.literal(<span class="hljs-string">&quot;candidate&quot;</span>)
    ),
    <span class="hljs-attr">signal</span>: v.string(),         <span class="hljs-comment">// The signaling data (SDP offer/answer or ICE candidate)</span>
  })
    .index(<span class="hljs-string">&quot;by_session_and_targetUser&quot;</span>, [<span class="hljs-string">&quot;sessionId&quot;</span>, <span class="hljs-string">&quot;targetUserId&quot;</span>])
    .index(<span class="hljs-string">&quot;by_session_and_user&quot;</span>, [<span class="hljs-string">&quot;sessionId&quot;</span>, <span class="hljs-string">&quot;userId&quot;</span>]),
});

</code></pre>
<h4 id=convex\videots anchor=true>convex\videots</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { v } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/values&quot;</span>;
<span class="hljs-keyword">import</span> { mutation, query } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./_generated/server&quot;</span>;

<span class="hljs-comment">/**
 * Send a WebRTC signaling message (offer, answer, or candidate)
 * to a specific user within a session.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> sendSignal = mutation({
  <span class="hljs-attr">args</span>: {
    <span class="hljs-attr">sessionId</span>: v.string(),
    <span class="hljs-attr">targetUserId</span>: v.string(),
    <span class="hljs-attr">type</span>: v.union(
      v.literal(<span class="hljs-string">&quot;offer&quot;</span>),
      v.literal(<span class="hljs-string">&quot;answer&quot;</span>),
      v.literal(<span class="hljs-string">&quot;candidate&quot;</span>)
    ),
    <span class="hljs-attr">signal</span>: v.string(),
  },
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, { sessionId, targetUserId, <span class="hljs-keyword">type</span>, signal }) =&gt; {
    <span class="hljs-keyword">const</span> identity = <span class="hljs-keyword">await</span> ctx.auth.getUserIdentity();
    <span class="hljs-keyword">if</span> (!identity) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;User must be authenticated to send signals.&quot;</span>);
    }
    <span class="hljs-keyword">const</span> senderUserId = identity.subject; <span class="hljs-comment">// Get user ID from identity</span>

    <span class="hljs-comment">// Basic validation (could add checks if users are part of the session)</span>
    <span class="hljs-keyword">if</span> (senderUserId === targetUserId) {
      <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">&quot;Attempting to send signal to self&quot;</span>);
      <span class="hljs-comment">// Usually, you don&#x27;t send signals to yourself, but might depend on logic</span>
      <span class="hljs-comment">// Decide if this should be an error or just logged</span>
    }

    <span class="hljs-keyword">await</span> ctx.db.insert(<span class="hljs-string">&quot;videoSignals&quot;</span>, {
      sessionId,
      <span class="hljs-attr">userId</span>: senderUserId, <span class="hljs-comment">// Use the authenticated user&#x27;s ID as the sender</span>
      targetUserId,
      <span class="hljs-keyword">type</span>,
      signal,
    });

    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Signal sent: <span class="hljs-subst">${<span class="hljs-keyword">type</span>}</span> from <span class="hljs-subst">${senderUserId}</span> to <span class="hljs-subst">${targetUserId}</span> in session <span class="hljs-subst">${sessionId}</span>`</span>);
  },
});

<span class="hljs-comment">/**
 * Query for WebRTC signaling messages directed at the current user
 * within a specific session.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getSignals = query({
  <span class="hljs-attr">args</span>: {
    <span class="hljs-attr">sessionId</span>: v.string(),
  },
  <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, { sessionId }) =&gt; {
    <span class="hljs-keyword">const</span> identity = <span class="hljs-keyword">await</span> ctx.auth.getUserIdentity();
    <span class="hljs-keyword">if</span> (!identity) {
      <span class="hljs-comment">// Return empty array or throw error if user not authenticated?</span>
      <span class="hljs-comment">// Returning empty might be safer for client-side logic.</span>
      <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">&quot;Unauthenticated user attempting to get signals.&quot;</span>)
      <span class="hljs-keyword">return</span> [];
    }
    <span class="hljs-keyword">const</span> currentUserId = identity.subject; <span class="hljs-comment">// Get user ID from identity</span>

    <span class="hljs-comment">// Fetch signals where the targetUserId matches the current authenticated user&#x27;s ID</span>
    <span class="hljs-keyword">const</span> signals = <span class="hljs-keyword">await</span> ctx.db
      .query(<span class="hljs-string">&quot;videoSignals&quot;</span>)
      .withIndex(<span class="hljs-string">&quot;by_session_and_targetUser&quot;</span>, <span class="hljs-function">(<span class="hljs-params">q</span>) =&gt;</span>
        q.eq(<span class="hljs-string">&quot;sessionId&quot;</span>, sessionId).eq(<span class="hljs-string">&quot;targetUserId&quot;</span>, currentUserId)
      )
      .collect();

    <span class="hljs-keyword">return</span> signals;
  },
});

<span class="hljs-comment">/**
 * Mutation to delete signals once they have been processed by the recipient.
 * This prevents reprocessing old signals.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> deleteSignal = mutation({
    <span class="hljs-attr">args</span>: { <span class="hljs-attr">signalId</span>: v.id(<span class="hljs-string">&quot;videoSignals&quot;</span>) },
    <span class="hljs-attr">handler</span>: <span class="hljs-keyword">async</span> (ctx, { signalId }) =&gt; {
        <span class="hljs-keyword">const</span> identity = <span class="hljs-keyword">await</span> ctx.auth.getUserIdentity();
        <span class="hljs-keyword">if</span> (!identity) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;User must be authenticated to delete signals.&quot;</span>);
        }
        <span class="hljs-keyword">const</span> currentUserId = identity.subject;

        <span class="hljs-comment">// Fetch the signal document first</span>
        <span class="hljs-keyword">const</span> signal = <span class="hljs-keyword">await</span> ctx.db.get(signalId);

        <span class="hljs-comment">// Only attempt deletion if the signal exists</span>
        <span class="hljs-keyword">if</span> (signal !== <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// Optional: You could re-add the check here if needed:</span>
            <span class="hljs-comment">// if (signal.targetUserId !== currentUserId) {</span>
            <span class="hljs-comment">//     console.warn(`User ${currentUserId} attempted to delete signal ${signalId} not targeted at them.`);</span>
            <span class="hljs-comment">//     // Decide whether to throw an error or just log and exit</span>
            <span class="hljs-comment">//     return; </span>
            <span class="hljs-comment">// }</span>
            
            <span class="hljs-keyword">await</span> ctx.db.delete(signalId);
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Signal <span class="hljs-subst">${signalId}</span> deleted by user <span class="hljs-subst">${currentUserId}</span>`</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Signal <span class="hljs-subst">${signalId}</span> not found, likely already deleted.`</span>);
        }
    }
});

</code></pre>
<h4 id=convex\_generated\apid.ts anchor=true>convex_generated\apid.ts</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-comment">/* eslint-disable */</span>
<span class="hljs-comment">/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * <span class="hljs-doctag">@module</span>
 */</span>

<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {
  ApiFromModules,
  FilterApi,
  FunctionReference,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/server&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> * <span class="hljs-keyword">as</span> auth <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../auth.js&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> * <span class="hljs-keyword">as</span> chat <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../chat.js&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> * <span class="hljs-keyword">as</span> events <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../events.js&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> * <span class="hljs-keyword">as</span> video <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../video.js&quot;</span>;

<span class="hljs-comment">/**
 * A utility for referencing Convex functions in your app&#x27;s API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> fullApi: ApiFromModules&lt;{
  <span class="hljs-attr">auth</span>: <span class="hljs-keyword">typeof</span> auth;
  chat: <span class="hljs-keyword">typeof</span> chat;
  events: <span class="hljs-keyword">typeof</span> events;
  video: <span class="hljs-keyword">typeof</span> video;
}&gt;;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> api: FilterApi&lt;
  <span class="hljs-keyword">typeof</span> fullApi,
  FunctionReference&lt;<span class="hljs-built_in">any</span>, <span class="hljs-string">&quot;public&quot;</span>&gt;
&gt;;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> internal: FilterApi&lt;
  <span class="hljs-keyword">typeof</span> fullApi,
  FunctionReference&lt;<span class="hljs-built_in">any</span>, <span class="hljs-string">&quot;internal&quot;</span>&gt;
&gt;;

</code></pre>
<h4 id=convex\_generated\apijs anchor=true>convex_generated\apijs</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-javascript"><span class="hljs-comment">/* eslint-disable */</span>
<span class="hljs-comment">/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * <span class="hljs-doctag">@module</span>
 */</span>

<span class="hljs-keyword">import</span> { anyApi } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/server&quot;</span>;

<span class="hljs-comment">/**
 * A utility for referencing Convex functions in your app&#x27;s API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> api = anyApi;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> internal = anyApi;

</code></pre>
<h4 id=convex\_generated\dataModeld.ts anchor=true>convex_generated\dataModeld.ts</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-comment">/* eslint-disable */</span>
<span class="hljs-comment">/**
 * Generated data model types.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * <span class="hljs-doctag">@module</span>
 */</span>

<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> {
  DataModelFromSchemaDefinition,
  DocumentByName,
  TableNamesInDataModel,
  SystemTableNames,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/server&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { GenericId } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/values&quot;</span>;
<span class="hljs-keyword">import</span> schema <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../schema.js&quot;</span>;

<span class="hljs-comment">/**
 * The names of all of your Convex tables.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> TableNames = TableNamesInDataModel&lt;DataModel&gt;;

<span class="hljs-comment">/**
 * The type of a document stored in Convex.
 *
 * <span class="hljs-doctag">@typeParam <span class="hljs-variable">TableName</span></span> - A string literal type of the table name (like &quot;users&quot;).
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> Doc&lt;TableName <span class="hljs-keyword">extends</span> TableNames&gt; = DocumentByName&lt;
  DataModel,
  TableName
&gt;;

<span class="hljs-comment">/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Document IDs](https://docs.convex.dev/using/document-ids).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * IDs are just strings at runtime, but this type can be used to distinguish them from other
 * strings when type checking.
 *
 * <span class="hljs-doctag">@typeParam <span class="hljs-variable">TableName</span></span> - A string literal type of the table name (like &quot;users&quot;).
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> Id&lt;TableName <span class="hljs-keyword">extends</span> TableNames | SystemTableNames&gt; =
  GenericId&lt;TableName&gt;;

<span class="hljs-comment">/**
 * A type describing your Convex data model.
 *
 * This type includes information about what tables you have, the type of
 * documents stored in those tables, and the indexes defined on them.
 *
 * This type is used to parameterize methods like `queryGeneric` and
 * `mutationGeneric` to make them type-safe.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> DataModel = DataModelFromSchemaDefinition&lt;<span class="hljs-keyword">typeof</span> schema&gt;;

</code></pre>
<h4 id=convex\_generated\serverd.ts anchor=true>convex_generated\serverd.ts</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-comment">/* eslint-disable */</span>
<span class="hljs-comment">/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * <span class="hljs-doctag">@module</span>
 */</span>

<span class="hljs-keyword">import</span> {
  ActionBuilder,
  HttpActionBuilder,
  MutationBuilder,
  QueryBuilder,
  GenericActionCtx,
  GenericMutationCtx,
  GenericQueryCtx,
  GenericDatabaseReader,
  GenericDatabaseWriter,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/server&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { DataModel } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./dataModel.js&quot;</span>;

<span class="hljs-comment">/**
 * Define a query in this Convex app&#x27;s public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * <span class="hljs-doctag">@param <span class="hljs-variable">func</span></span> - The query function. It receives a {<span class="hljs-doctag">@link </span>QueryCtx} as its first argument.
 * <span class="hljs-doctag">@returns </span>The wrapped query. Include this as an `export` to name it and make it accessible.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> query: QueryBuilder&lt;DataModel, <span class="hljs-string">&quot;public&quot;</span>&gt;;

<span class="hljs-comment">/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * <span class="hljs-doctag">@param <span class="hljs-variable">func</span></span> - The query function. It receives a {<span class="hljs-doctag">@link </span>QueryCtx} as its first argument.
 * <span class="hljs-doctag">@returns </span>The wrapped query. Include this as an `export` to name it and make it accessible.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> internalQuery: QueryBuilder&lt;DataModel, <span class="hljs-string">&quot;internal&quot;</span>&gt;;

<span class="hljs-comment">/**
 * Define a mutation in this Convex app&#x27;s public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * <span class="hljs-doctag">@param <span class="hljs-variable">func</span></span> - The mutation function. It receives a {<span class="hljs-doctag">@link </span>MutationCtx} as its first argument.
 * <span class="hljs-doctag">@returns </span>The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> mutation: MutationBuilder&lt;DataModel, <span class="hljs-string">&quot;public&quot;</span>&gt;;

<span class="hljs-comment">/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * <span class="hljs-doctag">@param <span class="hljs-variable">func</span></span> - The mutation function. It receives a {<span class="hljs-doctag">@link </span>MutationCtx} as its first argument.
 * <span class="hljs-doctag">@returns </span>The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> internalMutation: MutationBuilder&lt;DataModel, <span class="hljs-string">&quot;internal&quot;</span>&gt;;

<span class="hljs-comment">/**
 * Define an action in this Convex app&#x27;s public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex&#x27;s JavaScript environment or in Node.js using the &quot;use node&quot; directive.
 * They can interact with the database indirectly by calling queries and mutations using the {<span class="hljs-doctag">@link </span>ActionCtx}.
 *
 * <span class="hljs-doctag">@param <span class="hljs-variable">func</span></span> - The action. It receives an {<span class="hljs-doctag">@link </span>ActionCtx} as its first argument.
 * <span class="hljs-doctag">@returns </span>The wrapped action. Include this as an `export` to name it and make it accessible.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> action: ActionBuilder&lt;DataModel, <span class="hljs-string">&quot;public&quot;</span>&gt;;

<span class="hljs-comment">/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * <span class="hljs-doctag">@param <span class="hljs-variable">func</span></span> - The function. It receives an {<span class="hljs-doctag">@link </span>ActionCtx} as its first argument.
 * <span class="hljs-doctag">@returns </span>The wrapped function. Include this as an `export` to name it and make it accessible.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> internalAction: ActionBuilder&lt;DataModel, <span class="hljs-string">&quot;internal&quot;</span>&gt;;

<span class="hljs-comment">/**
 * Define an HTTP action.
 *
 * This function will be used to respond to HTTP requests received by a Convex
 * deployment if the requests matches the path and method where this action
 * is routed. Be sure to route your action in `convex/http.js`.
 *
 * <span class="hljs-doctag">@param <span class="hljs-variable">func</span></span> - The function. It receives an {<span class="hljs-doctag">@link </span>ActionCtx} as its first argument.
 * <span class="hljs-doctag">@returns </span>The wrapped function. Import this function from `convex/http.js` and route it to hook it up.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> httpAction: HttpActionBuilder;

<span class="hljs-comment">/**
 * A set of services for use within Convex query functions.
 *
 * The query context is passed as the first argument to any Convex query
 * function run on the server.
 *
 * This differs from the {<span class="hljs-doctag">@link </span>MutationCtx} because all of the services are
 * read-only.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> QueryCtx = GenericQueryCtx&lt;DataModel&gt;;

<span class="hljs-comment">/**
 * A set of services for use within Convex mutation functions.
 *
 * The mutation context is passed as the first argument to any Convex mutation
 * function run on the server.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> MutationCtx = GenericMutationCtx&lt;DataModel&gt;;

<span class="hljs-comment">/**
 * A set of services for use within Convex action functions.
 *
 * The action context is passed as the first argument to any Convex action
 * function run on the server.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> ActionCtx = GenericActionCtx&lt;DataModel&gt;;

<span class="hljs-comment">/**
 * An interface to read from the database within Convex query functions.
 *
 * The two entry points are {<span class="hljs-doctag">@link </span>DatabaseReader.get}, which fetches a single
 * document by its {<span class="hljs-doctag">@link </span>Id}, or {<span class="hljs-doctag">@link </span>DatabaseReader.query}, which starts
 * building a query.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> DatabaseReader = GenericDatabaseReader&lt;DataModel&gt;;

<span class="hljs-comment">/**
 * An interface to read from and write to the database within Convex mutation
 * functions.
 *
 * Convex guarantees that all writes within a single mutation are
 * executed atomically, so you never have to worry about partial writes leaving
 * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)
 * for the guarantees Convex provides your functions.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> DatabaseWriter = GenericDatabaseWriter&lt;DataModel&gt;;

</code></pre>
<h4 id=convex\_generated\serverjs anchor=true>convex_generated\serverjs</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-javascript"><span class="hljs-comment">/* eslint-disable */</span>
<span class="hljs-comment">/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * <span class="hljs-doctag">@module</span>
 */</span>

<span class="hljs-keyword">import</span> {
  actionGeneric,
  httpActionGeneric,
  queryGeneric,
  mutationGeneric,
  internalActionGeneric,
  internalMutationGeneric,
  internalQueryGeneric,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/server&quot;</span>;

<span class="hljs-comment">/**
 * Define a query in this Convex app&#x27;s public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * <span class="hljs-doctag">@param <span class="hljs-variable">func</span></span> - The query function. It receives a {<span class="hljs-doctag">@link </span>QueryCtx} as its first argument.
 * <span class="hljs-doctag">@returns </span>The wrapped query. Include this as an `export` to name it and make it accessible.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> query = queryGeneric;

<span class="hljs-comment">/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * <span class="hljs-doctag">@param <span class="hljs-variable">func</span></span> - The query function. It receives a {<span class="hljs-doctag">@link </span>QueryCtx} as its first argument.
 * <span class="hljs-doctag">@returns </span>The wrapped query. Include this as an `export` to name it and make it accessible.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> internalQuery = internalQueryGeneric;

<span class="hljs-comment">/**
 * Define a mutation in this Convex app&#x27;s public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * <span class="hljs-doctag">@param <span class="hljs-variable">func</span></span> - The mutation function. It receives a {<span class="hljs-doctag">@link </span>MutationCtx} as its first argument.
 * <span class="hljs-doctag">@returns </span>The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mutation = mutationGeneric;

<span class="hljs-comment">/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * <span class="hljs-doctag">@param <span class="hljs-variable">func</span></span> - The mutation function. It receives a {<span class="hljs-doctag">@link </span>MutationCtx} as its first argument.
 * <span class="hljs-doctag">@returns </span>The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> internalMutation = internalMutationGeneric;

<span class="hljs-comment">/**
 * Define an action in this Convex app&#x27;s public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex&#x27;s JavaScript environment or in Node.js using the &quot;use node&quot; directive.
 * They can interact with the database indirectly by calling queries and mutations using the {<span class="hljs-doctag">@link </span>ActionCtx}.
 *
 * <span class="hljs-doctag">@param <span class="hljs-variable">func</span></span> - The action. It receives an {<span class="hljs-doctag">@link </span>ActionCtx} as its first argument.
 * <span class="hljs-doctag">@returns </span>The wrapped action. Include this as an `export` to name it and make it accessible.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> action = actionGeneric;

<span class="hljs-comment">/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * <span class="hljs-doctag">@param <span class="hljs-variable">func</span></span> - The function. It receives an {<span class="hljs-doctag">@link </span>ActionCtx} as its first argument.
 * <span class="hljs-doctag">@returns </span>The wrapped function. Include this as an `export` to name it and make it accessible.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> internalAction = internalActionGeneric;

<span class="hljs-comment">/**
 * Define a Convex HTTP action.
 *
 * <span class="hljs-doctag">@param <span class="hljs-variable">func</span></span> - The function. It receives an {<span class="hljs-doctag">@link </span>ActionCtx} as its first argument, and a `Request` object
 * as its second.
 * <span class="hljs-doctag">@returns </span>The wrapped endpoint function. Route a URL path to this function in `convex/http.js`.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> httpAction = httpActionGeneric;

</code></pre>
<h4 id=dist\indexhtml anchor=true>dist\indexhtml</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Convex Chat<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">crossorigin</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/assets/index-S7rK6oc0.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">crossorigin</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/assets/index-Ca1NoLCf.css&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>

</code></pre>
<h4 id=indexhtml anchor=true>indexhtml</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Workoutmate<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/src/main.tsx&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>

</code></pre>
<h4 id=READMEmd anchor=true>READMEmd</h4>
<p><a href="#Contents">to top</a></p>
<h1 id=Workoutmate anchor=true>Workoutmate</h1>
<p>A workout companion app powered by Convex.</p>
<p>Follow the tutorial at<br>
<a href="https://docs.convex.dev/tutorial">docs.convex.dev/tutorial</a> for instructions.</p>
<h4 id=src\Apptsx anchor=true>src\Apptsx</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { Routes, Route, useLocation, useNavigate } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;
<span class="hljs-keyword">import</span> { Login, ProtectedRoute, OAuthCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/auth&quot;</span>;
<span class="hljs-keyword">import</span> { Calendar } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/calendar&quot;</span>;
<span class="hljs-keyword">import</span> { Session } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/session&quot;</span>;
<span class="hljs-keyword">import</span> { useUser } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@clerk/clerk-react&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> location = useLocation();
  <span class="hljs-keyword">const</span> navigate = useNavigate();
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">isLoaded</span>: clerkLoaded, isSignedIn, user } = useUser();

  <span class="hljs-comment">// When auth state changes, redirect appropriately</span>
  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Skip redirects if Clerk is still loading or we&#x27;re on the OAuth callback page</span>
    <span class="hljs-keyword">if</span> (!clerkLoaded || location.pathname === <span class="hljs-string">&quot;/oauth-callback&quot;</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (!isSignedIn) { 
      <span class="hljs-comment">// Only redirect if we&#x27;re not already on a auth page</span>
      <span class="hljs-keyword">if</span> (
        location.pathname !== <span class="hljs-string">&quot;/login&quot;</span> &amp;&amp;
        location.pathname !== <span class="hljs-string">&quot;/register&quot;</span> &amp;&amp;
        location.pathname !== <span class="hljs-string">&quot;/oauth-callback&quot;</span>
      ) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Not authenticated, redirecting to login&quot;</span>);
        navigate(<span class="hljs-string">&quot;/login&quot;</span>);
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (
      location.pathname === <span class="hljs-string">&quot;/login&quot;</span> ||
      location.pathname === <span class="hljs-string">&quot;/register&quot;</span>
    ) {
      <span class="hljs-comment">// If logged in but on auth page, redirect to home</span>
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Already authenticated, redirecting to home&quot;</span>);
      navigate(<span class="hljs-string">&quot;/&quot;</span>);
    }
  }, [isSignedIn, navigate, location.pathname, clerkLoaded]);

  <span class="hljs-comment">// Main route structure</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Login</span> <span class="hljs-attr">isRegistering</span>=<span class="hljs-string">{false}</span> /&gt;</span>} /&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/register&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Login</span> <span class="hljs-attr">isRegistering</span>=<span class="hljs-string">{true}</span> /&gt;</span>} /&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/oauth-callback&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">OAuthCallback</span> /&gt;</span>} /&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span>
        <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span>
        <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>
          &lt;<span class="hljs-attr">ProtectedRoute</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">Calendar</span> /&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">ProtectedRoute</span>&gt;</span>
        }
      /&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span>
        <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/session/:sessionId&quot;</span>
        <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>
          &lt;<span class="hljs-attr">ProtectedRoute</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">Session</span> /&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">ProtectedRoute</span>&gt;</span>
        }
      /&gt;
    <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span>
  );
}

</code></pre>
<h4 id=src\components\auth\indexts anchor=true>src\components\auth\indexts</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">export</span> { Login } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Login&quot;</span>;
<span class="hljs-keyword">export</span> { ProtectedRoute } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ProtectedRoute&quot;</span>;
<span class="hljs-keyword">export</span> { OAuthCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./OAuthCallback&quot;</span>;

</code></pre>
<h4 id=src\components\auth\Logintsx anchor=true>src\components\auth\Logintsx</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { useNavigate } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Login.module.css&quot;</span>;
<span class="hljs-keyword">import</span> workoutImage <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../assets/images/workoutmate.webp&quot;</span>;
<span class="hljs-keyword">import</span> { useSignIn, useClerk, useUser, SignIn, SignUp } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@clerk/clerk-react&quot;</span>; 

<span class="hljs-keyword">interface</span> LoginProps {
  <span class="hljs-attr">isRegistering</span>: <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Login</span>(<span class="hljs-params">{ isRegistering }: LoginProps</span>) </span>{
  <span class="hljs-keyword">const</span> [isProcessingGoogle, setIsProcessingGoogle] = useState(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> navigate = useNavigate();
  <span class="hljs-keyword">const</span> { signIn, <span class="hljs-attr">isLoaded</span>: clerkLoaded } = useSignIn();
  <span class="hljs-keyword">const</span> clerk = useClerk();
  <span class="hljs-keyword">const</span> { isSignedIn } = useUser();

  <span class="hljs-keyword">const</span> handleGoogleSignIn = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">if</span> (!clerkLoaded || !signIn) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Clerk not ready for Google Sign-In&quot;</span>);
        <span class="hljs-keyword">return</span>;
      }
      
      setIsProcessingGoogle(<span class="hljs-literal">true</span>);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Starting Google sign-in process&quot;</span>);
      
      <span class="hljs-keyword">if</span> (clerk.session) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Clearing existing session&quot;</span>);
        <span class="hljs-keyword">await</span> clerk.signOut();
      }
      
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Redirecting to Google OAuth&quot;</span>);
      <span class="hljs-keyword">await</span> signIn.authenticateWithRedirect({
        <span class="hljs-attr">strategy</span>: <span class="hljs-string">&quot;oauth_google&quot;</span>,
        <span class="hljs-attr">redirectUrl</span>: <span class="hljs-built_in">window</span>.location.origin + <span class="hljs-string">&quot;/oauth-callback&quot;</span>,
        <span class="hljs-attr">redirectUrlComplete</span>: <span class="hljs-built_in">window</span>.location.origin + <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-comment">// Redirect to home after completion</span>
      });
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Google sign-in failed:&quot;</span>, error);
      setIsProcessingGoogle(<span class="hljs-literal">false</span>);
    }
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.loginContainer}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.loginWrapper}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.loginCard}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Workoutmate<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
          
          {isRegistering ? (
            <span class="hljs-tag">&lt;<span class="hljs-name">SignUp</span> 
              <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/register&quot;</span> 
              <span class="hljs-attr">routing</span>=<span class="hljs-string">&quot;path&quot;</span> 
              <span class="hljs-attr">signInUrl</span>=<span class="hljs-string">&quot;/login&quot;</span> // <span class="hljs-attr">URL</span> <span class="hljs-attr">to</span> <span class="hljs-attr">navigate</span> <span class="hljs-attr">to</span> <span class="hljs-attr">for</span> <span class="hljs-attr">sign-in</span>
              <span class="hljs-attr">forceRedirectUrl</span>=<span class="hljs-string">&quot;/&quot;</span> // <span class="hljs-attr">Redirect</span> <span class="hljs-attr">after</span> <span class="hljs-attr">successful</span> <span class="hljs-attr">sign-up</span>
            /&gt;</span>
          ) : (
            <span class="hljs-tag">&lt;<span class="hljs-name">SignIn</span> 
              <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/login&quot;</span> 
              <span class="hljs-attr">routing</span>=<span class="hljs-string">&quot;path&quot;</span> 
              <span class="hljs-attr">signUpUrl</span>=<span class="hljs-string">&quot;/register&quot;</span> // <span class="hljs-attr">URL</span> <span class="hljs-attr">to</span> <span class="hljs-attr">navigate</span> <span class="hljs-attr">to</span> <span class="hljs-attr">for</span> <span class="hljs-attr">sign-up</span>
              <span class="hljs-attr">forceRedirectUrl</span>=<span class="hljs-string">&quot;/&quot;</span> // <span class="hljs-attr">Redirect</span> <span class="hljs-attr">after</span> <span class="hljs-attr">successful</span> <span class="hljs-attr">sign-in</span>
            /&gt;</span>
          )}

          {/* <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.divider}</span>&gt;</span> 
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>OR<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
            <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleGoogleSignIn}</span>
            <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">styles.loginButton</span>} ${<span class="hljs-attr">styles.googleButton</span>}`}
            <span class="hljs-attr">disabled</span>=<span class="hljs-string">{!clerkLoaded</span> || <span class="hljs-attr">isProcessingGoogle</span>}
          &gt;</span>
            {isProcessingGoogle ? &quot;Processing...&quot; : &quot;Continue with Google&quot;}
          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> */}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.imageContainer}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{workoutImage}</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Workout illustration&quot;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.workoutImage}</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<h4 id=src\components\auth\OAuthCallbacktsx anchor=true>src\components\auth\OAuthCallbacktsx</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { useNavigate } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;
<span class="hljs-keyword">import</span> { useAuth } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../contexts/AuthContext&quot;</span>;
<span class="hljs-keyword">import</span> { useClerk, useUser } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@clerk/clerk-react&quot;</span>;
<span class="hljs-keyword">import</span> { useMutation } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/react&quot;</span>;
<span class="hljs-keyword">import</span> { api } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../../convex/_generated/api&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">OAuthCallback</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> navigate = useNavigate();
  <span class="hljs-keyword">const</span> { isSignedIn, user, <span class="hljs-attr">isLoaded</span>: userIsLoaded } = useUser();
  <span class="hljs-keyword">const</span> { login, isAuthenticated } = useAuth();
  <span class="hljs-keyword">const</span> getUserFromClerk = useMutation(api.auth.getUserFromClerk);
  <span class="hljs-keyword">const</span> clerk = useClerk();
  <span class="hljs-keyword">const</span> [isProcessing, setIsProcessing] = useState(<span class="hljs-literal">true</span>);
  <span class="hljs-keyword">const</span> [error, setError] = useState&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [statusMessage, setStatusMessage] = useState(<span class="hljs-string">&quot;Initializing authentication...&quot;</span>);

  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Debug logging to track the flow</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;OAuth callback - Auth state:&quot;</span>, { 
      isSignedIn, 
      <span class="hljs-attr">userLoaded</span>: userIsLoaded,
      <span class="hljs-attr">hasUser</span>: !!user,
      <span class="hljs-attr">userId</span>: user?.id,
      <span class="hljs-attr">isAuthenticatedInContext</span>: isAuthenticated
    });

    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleOAuthCallback</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!userIsLoaded) {
        setStatusMessage(<span class="hljs-string">&quot;Loading user data...&quot;</span>);
        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Wait for user data to load</span>
      }

      <span class="hljs-comment">// If already authenticated in our context, we can navigate directly</span>
      <span class="hljs-keyword">if</span> (isAuthenticated) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Already authenticated in context, navigating to home&quot;</span>);
        setStatusMessage(<span class="hljs-string">&quot;Already authenticated, redirecting...&quot;</span>);
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> navigate(<span class="hljs-string">&quot;/&quot;</span>), <span class="hljs-number">500</span>);
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">try</span> {
        setIsProcessing(<span class="hljs-literal">true</span>);
        
        <span class="hljs-keyword">if</span> (isSignedIn &amp;&amp; user) {
          setStatusMessage(<span class="hljs-string">&quot;User authenticated with Clerk, creating Convex user...&quot;</span>);
          
          <span class="hljs-comment">// Get email or fall back to username</span>
          <span class="hljs-keyword">const</span> userIdentifier = user.emailAddresses.length &gt; <span class="hljs-number">0</span> 
            ? user.emailAddresses[<span class="hljs-number">0</span>].emailAddress 
            : (user.username || <span class="hljs-string">`user-<span class="hljs-subst">${user.id}</span>`</span>);
          
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Creating/getting Convex user with identifier:&quot;</span>, userIdentifier);
            
          <span class="hljs-comment">// Create or get user in Convex</span>
          <span class="hljs-keyword">const</span> convexUser = <span class="hljs-keyword">await</span> getUserFromClerk({
            <span class="hljs-attr">clerkId</span>: user.id,
            <span class="hljs-attr">username</span>: userIdentifier,
          });

          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Convex user created/retrieved:&quot;</span>, convexUser);

          <span class="hljs-comment">// Login with AuthContext</span>
          login(convexUser.userId, convexUser.username);
          setStatusMessage(<span class="hljs-string">&quot;Authentication successful, redirecting...&quot;</span>);
          
          <span class="hljs-comment">// Redirect to the home page with a slight delay to ensure state updates</span>
          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> navigate(<span class="hljs-string">&quot;/&quot;</span>), <span class="hljs-number">1000</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (userIsLoaded &amp;&amp; !isSignedIn) {
          <span class="hljs-comment">// User loaded but not signed in</span>
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;User data loaded but not signed in&quot;</span>);
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;OAuth authentication failed - Not signed in after loading user data&quot;</span>);
        }
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Error in OAuth callback:&quot;</span>, error);
        setError(<span class="hljs-string">&quot;Authentication failed. Please try again.&quot;</span>);
        setStatusMessage(<span class="hljs-string">&quot;Authentication error, redirecting to login...&quot;</span>);
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> navigate(<span class="hljs-string">&quot;/login&quot;</span>), <span class="hljs-number">2000</span>);
      } <span class="hljs-keyword">finally</span> {
        setIsProcessing(<span class="hljs-literal">false</span>);
      }
    }

    handleOAuthCallback();
  }, [isSignedIn, user, userIsLoaded, login, getUserFromClerk, navigate, clerk, isAuthenticated]);

  <span class="hljs-keyword">if</span> (error) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> 
        <span class="hljs-attr">display:</span> &#x27;<span class="hljs-attr">flex</span>&#x27;, 
        <span class="hljs-attr">justifyContent:</span> &#x27;<span class="hljs-attr">center</span>&#x27;, 
        <span class="hljs-attr">alignItems:</span> &#x27;<span class="hljs-attr">center</span>&#x27;, 
        <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">100vh</span>&#x27;, 
        <span class="hljs-attr">flexDirection:</span> &#x27;<span class="hljs-attr">column</span>&#x27; 
      }}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Authentication Error<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{error}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Redirecting you back to login...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> 
      <span class="hljs-attr">display:</span> &#x27;<span class="hljs-attr">flex</span>&#x27;, 
      <span class="hljs-attr">justifyContent:</span> &#x27;<span class="hljs-attr">center</span>&#x27;, 
      <span class="hljs-attr">alignItems:</span> &#x27;<span class="hljs-attr">center</span>&#x27;, 
      <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">100vh</span>&#x27;, 
      <span class="hljs-attr">flexDirection:</span> &#x27;<span class="hljs-attr">column</span>&#x27; 
    }}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Completing login...<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{statusMessage}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
} 
</code></pre>
<h4 id=src\components\auth\ProtectedRoutetsx anchor=true>src\components\auth\ProtectedRoutetsx</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Navigate } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;
<span class="hljs-keyword">import</span> { useUser } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@clerk/clerk-react&quot;</span>;

<span class="hljs-keyword">interface</span> ProtectedRouteProps {
  <span class="hljs-attr">children</span>: React.ReactNode;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ProtectedRoute = <span class="hljs-function">(<span class="hljs-params">{ children }: ProtectedRouteProps</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { isLoaded, isSignedIn } = useUser();

  <span class="hljs-keyword">if</span> (!isLoaded) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading authentication...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
  }

  <span class="hljs-keyword">if</span> (!isSignedIn) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">replace</span> /&gt;</span></span>;
  }

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span>{children}<span class="hljs-tag">&lt;/&gt;</span></span>;
};
</code></pre>
<h4 id=src\components\calendar\Calendartsx anchor=true>src\components\calendar\Calendartsx</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> FullCalendar <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@fullcalendar/react&quot;</span>;
<span class="hljs-keyword">import</span> dayGridPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@fullcalendar/daygrid&quot;</span>;
<span class="hljs-keyword">import</span> timeGridPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@fullcalendar/timegrid&quot;</span>;
<span class="hljs-keyword">import</span> interactionPlugin, { DateClickArg } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@fullcalendar/interaction&quot;</span>;
<span class="hljs-keyword">import</span> { Header } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../layout&quot;</span>;
<span class="hljs-keyword">import</span> { useUser } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@clerk/clerk-react&quot;</span>;
<span class="hljs-keyword">import</span> { useMutation, useQuery } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/react&quot;</span>;
<span class="hljs-keyword">import</span> { api } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../convex&quot;</span>;
<span class="hljs-keyword">import</span> { CalendarOptions } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@fullcalendar/core&quot;</span>;
<span class="hljs-keyword">import</span> { CustomEvent } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./CustomEvent&quot;</span>;
<span class="hljs-keyword">import</span> { EventModal } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./EventModal&quot;</span>;
<span class="hljs-keyword">import</span> { SessionDetailsModal } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./SessionDetailsModal&quot;</span>;
<span class="hljs-keyword">import</span> { Id } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../../convex/_generated/dataModel&quot;</span>;
<span class="hljs-keyword">import</span> { showToast } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../utils/toast&quot;</span>;
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Calendar.module.css&quot;</span>;

<span class="hljs-keyword">interface</span> CalendarProps {}

<span class="hljs-keyword">interface</span> CalendarEvent {
  <span class="hljs-attr">id</span>: Id&lt;<span class="hljs-string">&quot;events&quot;</span>&gt;;
  title: <span class="hljs-built_in">string</span>;
  start: <span class="hljs-built_in">string</span>;
  end: <span class="hljs-built_in">string</span>;
  creatorName: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Calendar</span>(<span class="hljs-params">{}: CalendarProps</span>) </span>{
  <span class="hljs-keyword">const</span> { isLoaded, isSignedIn, user } = useUser();

  <span class="hljs-keyword">const</span> currentUserId = isLoaded &amp;&amp; isSignedIn ? user.id : <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">const</span> currentUsername = isLoaded &amp;&amp; isSignedIn ? user.username : <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">const</span> [isModalOpen, setIsModalOpen] = useState(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [isDetailsModalOpen, setIsDetailsModalOpen] = useState(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [selectedDate, setSelectedDate] = useState&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;&quot;</span>);
  <span class="hljs-keyword">const</span> [selectedEvent, setSelectedEvent] = useState&lt;CalendarEvent | <span class="hljs-literal">null</span>&gt;(
    <span class="hljs-literal">null</span>
  );
  <span class="hljs-keyword">const</span> [viewingEvent, setViewingEvent] = useState&lt;CalendarEvent | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// Use Convex to manage events</span>
  <span class="hljs-keyword">const</span> createEvent = useMutation(api.events.create);
  <span class="hljs-keyword">const</span> updateEvent = useMutation(api.events.update);
  <span class="hljs-keyword">const</span> deleteEvent = useMutation(api.events.deleteEvent);
  <span class="hljs-keyword">const</span> allEvents = useQuery(api.events.getAllEvents) || [];

  <span class="hljs-comment">// Transform Convex events to the format FullCalendar expects</span>
  <span class="hljs-keyword">const</span> events = allEvents.map(<span class="hljs-function">(<span class="hljs-params">event: <span class="hljs-built_in">any</span></span>) =&gt;</span> ({
    <span class="hljs-attr">id</span>: event._id,
    <span class="hljs-attr">creatorName</span>: event.creatorName, <span class="hljs-comment">// Keep the original creator name</span>
    <span class="hljs-comment">// Include creator name with the title, show &quot;You&quot; for current user&#x27;s events</span>
    <span class="hljs-attr">title</span>:
      event.creatorName === currentUsername
        ? <span class="hljs-string">`You: <span class="hljs-subst">${event.title}</span>`</span>
        : event.creatorName &amp;&amp; event.creatorName !== <span class="hljs-string">&quot;Unknown User&quot;</span>
          ? <span class="hljs-string">`<span class="hljs-subst">${event.creatorName}</span>: <span class="hljs-subst">${event.title}</span>`</span>
          : event.title,
    <span class="hljs-attr">start</span>: event.start,
    <span class="hljs-attr">end</span>: event.end,
  }));

  <span class="hljs-comment">// Handle date click - open modal for new event creation</span>
  <span class="hljs-keyword">const</span> handleDateClick = <span class="hljs-function">(<span class="hljs-params">info: DateClickArg</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> clickedDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(info.dateStr);
    <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
    
    <span class="hljs-comment">// Check if the clicked date is in the past</span>
    <span class="hljs-keyword">if</span> (clickedDate &lt; now) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Calendar - Rejected date click: Past date detected&quot;</span>, info.dateStr);
      showToast.session.pastDateError();
      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Early return without opening the modal</span>
    }
    
    <span class="hljs-comment">// Only executed for future dates</span>
    setSelectedEvent(<span class="hljs-literal">null</span>); <span class="hljs-comment">// Clear any selected event</span>
    setSelectedDate(info.dateStr);
    setIsModalOpen(<span class="hljs-literal">true</span>);
  };

  <span class="hljs-comment">// Handle event click - show details modal for all events</span>
  <span class="hljs-keyword">const</span> handleEventClick = <span class="hljs-function">(<span class="hljs-params">info: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> event = events.find(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e.id === info.event.id);
    <span class="hljs-keyword">if</span> (!event) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">const</span> [, ...titleParts] = event.title.split(<span class="hljs-string">&quot;: &quot;</span>);
    <span class="hljs-keyword">const</span> eventTitle =
      titleParts.length &gt; <span class="hljs-number">0</span> ? titleParts.join(<span class="hljs-string">&quot;: &quot;</span>) : event.title;
    <span class="hljs-keyword">const</span> eventData = {
      <span class="hljs-attr">id</span>: event.id,
      <span class="hljs-attr">title</span>: eventTitle,
      <span class="hljs-attr">start</span>: event.start,
      <span class="hljs-attr">end</span>: event.end,
      <span class="hljs-attr">creatorName</span>: event.creatorName,
    };

    setViewingEvent(eventData);
    setIsDetailsModalOpen(<span class="hljs-literal">true</span>);
  };

  <span class="hljs-comment">// Handle direct edit click from the event</span>
  <span class="hljs-keyword">const</span> handleEventEditClick = <span class="hljs-function">(<span class="hljs-params">info: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> event = events.find(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e.id === info.event.id);
    <span class="hljs-keyword">if</span> (!event) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">const</span> [, ...titleParts] = event.title.split(<span class="hljs-string">&quot;: &quot;</span>);
    <span class="hljs-keyword">const</span> eventTitle =
      titleParts.length &gt; <span class="hljs-number">0</span> ? titleParts.join(<span class="hljs-string">&quot;: &quot;</span>) : event.title;
    <span class="hljs-keyword">const</span> eventData = {
      <span class="hljs-attr">id</span>: event.id,
      <span class="hljs-attr">title</span>: eventTitle,
      <span class="hljs-attr">start</span>: event.start,
      <span class="hljs-attr">end</span>: event.end,
      <span class="hljs-attr">creatorName</span>: event.creatorName,
    };

    setSelectedEvent(eventData);
    setIsModalOpen(<span class="hljs-literal">true</span>);
  };

  <span class="hljs-comment">// Handle switching from details to edit mode</span>
  <span class="hljs-keyword">const</span> handleEditEvent = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (viewingEvent) {
      setSelectedEvent(viewingEvent);
      setIsDetailsModalOpen(<span class="hljs-literal">false</span>);
      setIsModalOpen(<span class="hljs-literal">true</span>);
    }
  };

  <span class="hljs-comment">// Handle event deletion</span>
  <span class="hljs-keyword">const</span> handleEventDelete = <span class="hljs-keyword">async</span> (eventId: Id&lt;<span class="hljs-string">&quot;events&quot;</span>&gt;) =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Calendar - Deleting event:&quot;</span>, eventId);
      <span class="hljs-keyword">await</span> deleteEvent({ <span class="hljs-attr">id</span>: eventId });
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Calendar - Event deleted successfully&quot;</span>);
      showToast.session.deleted();
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve();
    } <span class="hljs-keyword">catch</span> (error: <span class="hljs-built_in">any</span>) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Calendar - Error deleting event:&quot;</span>, error);
      showToast.error(error.message || <span class="hljs-string">&quot;Failed to delete session&quot;</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);
    }
  };

  <span class="hljs-comment">// Handle event creation/update from modal</span>
  <span class="hljs-keyword">const</span> handleEventSubmit = <span class="hljs-keyword">async</span> ({
    title,
    start,
    end,
  }: {
    <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;
    start: <span class="hljs-built_in">string</span>;
    end: <span class="hljs-built_in">string</span>;
  }): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {
    <span class="hljs-comment">// Add guard clause for authentication</span>
    <span class="hljs-keyword">if</span> (!isSignedIn || !user) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;User not authenticated, cannot submit event.&quot;</span>);
      showToast.error(<span class="hljs-string">&quot;Authentication error, please log in again.&quot;</span>);
      <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Calendar - Submitting event:&quot;</span>, {
        <span class="hljs-attr">isEdit</span>: !!selectedEvent?.id,
        title,
        start,
        end
      });

      <span class="hljs-keyword">if</span> (selectedEvent?.id) {
        <span class="hljs-comment">// Update existing event</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Calendar - Updating existing event:&quot;</span>, selectedEvent.id);
        <span class="hljs-keyword">await</span> updateEvent({
          <span class="hljs-attr">id</span>: selectedEvent.id,
          title,
          start,
          end,
        });
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Calendar - Event updated successfully&quot;</span>);
        showToast.session.updated();
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (user) {
        <span class="hljs-comment">// Create new event</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Calendar - Creating new event for user:&quot;</span>, user.id);
        <span class="hljs-keyword">const</span> eventId = <span class="hljs-keyword">await</span> createEvent({
          <span class="hljs-attr">userId</span>: user.id,
          title,
          start,
          end,
        });
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Calendar - Event created successfully:&quot;</span>, eventId);
        showToast.session.created();
      }
    } <span class="hljs-keyword">catch</span> (error: <span class="hljs-built_in">any</span>) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Calendar - Error submitting event:&quot;</span>, error);
      <span class="hljs-keyword">if</span> (error.message.includes(<span class="hljs-string">&quot;past date&quot;</span>)) {
        showToast.session.pastDateError();
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.message.includes(<span class="hljs-string">&quot;overlapping&quot;</span>)) {
        showToast.session.overlapError();
      } <span class="hljs-keyword">else</span> {
        showToast.error(error.message || <span class="hljs-string">&quot;Failed to create/update session&quot;</span>);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);
    }
  };

  <span class="hljs-comment">// Configure calendar options</span>
  <span class="hljs-keyword">const</span> calendarOptions: CalendarOptions = {
    <span class="hljs-attr">plugins</span>: [dayGridPlugin, timeGridPlugin, interactionPlugin],
    <span class="hljs-attr">initialView</span>: <span class="hljs-string">&quot;timeGridWeek&quot;</span>,
    <span class="hljs-attr">weekends</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">events</span>: events,
    <span class="hljs-attr">height</span>: <span class="hljs-string">&quot;100%&quot;</span>,
    <span class="hljs-attr">headerToolbar</span>: {
      <span class="hljs-attr">left</span>: <span class="hljs-string">&quot;prev,next today&quot;</span>,
      <span class="hljs-attr">center</span>: <span class="hljs-string">&quot;title&quot;</span>,
      <span class="hljs-attr">right</span>: <span class="hljs-string">&quot;dayGridMonth,timeGridWeek,timeGridDay&quot;</span>,
    },
    <span class="hljs-attr">editable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">selectable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">dateClick</span>: handleDateClick,
    <span class="hljs-attr">eventClick</span>: handleEventClick,
    <span class="hljs-attr">nowIndicator</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">scrollTime</span>: <span class="hljs-string">&quot;08:00:00&quot;</span>,
    <span class="hljs-comment">// Additional time slot configuration options</span>
    <span class="hljs-attr">slotDuration</span>: <span class="hljs-string">&quot;00:15:00&quot;</span>, <span class="hljs-comment">// 30-minute slots (default)</span>
    <span class="hljs-attr">slotLabelInterval</span>: <span class="hljs-string">&quot;01:00:00&quot;</span>, <span class="hljs-comment">// Show labels every hour</span>
    <span class="hljs-attr">slotMinTime</span>: <span class="hljs-string">&quot;00:00:00&quot;</span>, <span class="hljs-comment">// Start at midnight</span>
    <span class="hljs-attr">slotMaxTime</span>: <span class="hljs-string">&quot;24:00:00&quot;</span>, <span class="hljs-comment">// End at midnight</span>
    <span class="hljs-attr">eventContent</span>: <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> timeText =
        arg.timeText ||
        <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(arg.event.startStr).toLocaleTimeString([], {
          <span class="hljs-attr">hour</span>: <span class="hljs-string">&quot;2-digit&quot;</span>,
          <span class="hljs-attr">minute</span>: <span class="hljs-string">&quot;2-digit&quot;</span>,
        });
      <span class="hljs-keyword">const</span> event = events.find(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e.id === arg.event.id);
      <span class="hljs-keyword">const</span> isCurrentUser = event?.creatorName === currentUsername;
      <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CustomEvent</span>
          <span class="hljs-attr">event</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">title:</span> <span class="hljs-attr">arg.event.title</span>, <span class="hljs-attr">timeText</span> }}
          <span class="hljs-attr">isCurrentUser</span>=<span class="hljs-string">{isCurrentUser}</span>
          <span class="hljs-attr">onEditClick</span>=<span class="hljs-string">{()</span> =&gt;</span> handleEventEditClick(arg)}
        /&gt;</span>
      );
    },
  };

  <span class="hljs-comment">// Handle loading state from Clerk</span>
  <span class="hljs-keyword">if</span> (!isLoaded) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.calendarContainer}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span> 
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.loading}</span>&gt;</span>Loading user information...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }

  <span class="hljs-comment">// Handle unauthenticated state (though ProtectedRoute should prevent this)</span>
  <span class="hljs-keyword">if</span> (!isSignedIn) {
     <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.calendarContainer}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span> 
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.loading}</span>&gt;</span>Please log in to view the calendar.<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.calendarContainer}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span> 
      <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.calendar}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">FullCalendar</span> {<span class="hljs-attr">...calendarOptions</span>} /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">EventModal</span>
        <span class="hljs-attr">isOpen</span>=<span class="hljs-string">{isModalOpen}</span>
        <span class="hljs-attr">onClose</span>=<span class="hljs-string">{()</span> =&gt;</span> {
          setIsModalOpen(false);
          setSelectedEvent(null);
        }}
        onSubmit={handleEventSubmit}
        onDelete={selectedEvent?.creatorName === currentUsername ? handleEventDelete : undefined}
        dateStr={selectedDate}
        event={selectedEvent}
        userId={user?.id ?? &#x27;&#x27;}
      /&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">SessionDetailsModal</span>
        <span class="hljs-attr">isOpen</span>=<span class="hljs-string">{isDetailsModalOpen}</span>
        <span class="hljs-attr">onClose</span>=<span class="hljs-string">{()</span> =&gt;</span> {
          setIsDetailsModalOpen(false);
          setViewingEvent(null);
        }}
        event={viewingEvent}
        isOwnEvent={viewingEvent?.creatorName === currentUsername}
        onEdit={handleEditEvent}
      /&gt;
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

</code></pre>
<h4 id=src\components\calendar\CustomEventtsx anchor=true>src\components\calendar\CustomEventtsx</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./CustomEvent.module.css&quot;</span>;

<span class="hljs-keyword">interface</span> CustomEventProps {
  <span class="hljs-attr">event</span>: {
    <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;
    timeText: <span class="hljs-built_in">string</span>;
  };
  isCurrentUser: <span class="hljs-built_in">boolean</span>;
  onEditClick?: <span class="hljs-function">(<span class="hljs-params">e: React.MouseEvent</span>) =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> CustomEvent: React.FC&lt;CustomEventProps&gt; = <span class="hljs-function">(<span class="hljs-params">{
  event,
  isCurrentUser,
  onEditClick,
}</span>) =&gt;</span> {
  <span class="hljs-comment">// Split the title to separate creator name and event title if present</span>
  <span class="hljs-keyword">const</span> [creatorName, ...titleParts] = event.title.split(<span class="hljs-string">&quot;: &quot;</span>);
  <span class="hljs-keyword">const</span> eventTitle =
    titleParts.length &gt; <span class="hljs-number">0</span> ? titleParts.join(<span class="hljs-string">&quot;: &quot;</span>) : creatorName;

  <span class="hljs-keyword">const</span> handleEditClick = <span class="hljs-function">(<span class="hljs-params">e: React.MouseEvent</span>) =&gt;</span> {
    e.stopPropagation(); <span class="hljs-comment">// Prevent event click from triggering</span>
    onEditClick?.(e);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>
      <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">styles.customEvent</span>} ${<span class="hljs-attr">isCurrentUser</span> ? <span class="hljs-attr">styles.currentUserEvent</span> <span class="hljs-attr">:</span> &quot;&quot;}`}
    &gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.eventTime}</span>&gt;</span>{event.timeText}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      {titleParts.length &gt; 0 &amp;&amp; (
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.eventCreator}</span>&gt;</span>{creatorName}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      )}
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.eventTitle}</span>&gt;</span>{eventTitle}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      {isCurrentUser &amp;&amp; (
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.editButton}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleEditClick}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>✎<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Edit<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      )}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

</code></pre>
<h4 id=src\components\calendar\EventModaltsx anchor=true>src\components\calendar\EventModaltsx</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> React, { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./EventModal.module.css&quot;</span>;
<span class="hljs-keyword">import</span> { useQuery } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/react&quot;</span>;
<span class="hljs-keyword">import</span> { api } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../convex&quot;</span>;
<span class="hljs-keyword">import</span> { showToast } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../utils/toast&quot;</span>;

<span class="hljs-comment">// Helper function to format date for datetime-local input</span>
<span class="hljs-keyword">const</span> formatDateForInput = (date: <span class="hljs-built_in">Date</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> year = date.getFullYear();
  <span class="hljs-keyword">const</span> month = <span class="hljs-built_in">String</span>(date.getMonth() + <span class="hljs-number">1</span>).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>);
  <span class="hljs-keyword">const</span> day = <span class="hljs-built_in">String</span>(date.getDate()).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>);
  <span class="hljs-keyword">const</span> hours = <span class="hljs-built_in">String</span>(date.getHours()).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>);
  <span class="hljs-keyword">const</span> minutes = <span class="hljs-built_in">String</span>(date.getMinutes()).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${year}</span>-<span class="hljs-subst">${month}</span>-<span class="hljs-subst">${day}</span>T<span class="hljs-subst">${hours}</span>:<span class="hljs-subst">${minutes}</span>`</span>;
};

<span class="hljs-comment">// Helper function to get initial date value</span>
<span class="hljs-keyword">const</span> getInitialDate = (dateStr: <span class="hljs-built_in">string</span>, addHour = <span class="hljs-literal">false</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// Handle both ISO string and FullCalendar&#x27;s date string formats</span>
    <span class="hljs-comment">// FullCalendar format example: &quot;2024-03-15T09:00:00&quot;</span>
    <span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(dateStr);

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(date.getTime())) {
      <span class="hljs-comment">// If parsing fails, try parsing as a FullCalendar date string</span>
      <span class="hljs-keyword">const</span> [datePart, timePart] = dateStr.split(<span class="hljs-string">&quot;T&quot;</span>);
      <span class="hljs-keyword">if</span> (datePart &amp;&amp; timePart) {
        <span class="hljs-keyword">const</span> [year, month, day] = datePart.split(<span class="hljs-string">&quot;-&quot;</span>).map(<span class="hljs-built_in">Number</span>);
        <span class="hljs-keyword">const</span> [hours, minutes] = timePart.split(<span class="hljs-string">&quot;:&quot;</span>).map(<span class="hljs-built_in">Number</span>);
        <span class="hljs-keyword">const</span> newDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(year, month - <span class="hljs-number">1</span>, day, hours, minutes);
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(newDate.getTime())) {
          <span class="hljs-keyword">if</span> (addHour) {
            newDate.setHours(newDate.getHours() + <span class="hljs-number">1</span>);
          }
          <span class="hljs-keyword">return</span> formatDateForInput(newDate);
        }
      }

      <span class="hljs-comment">// If all parsing fails, use current time</span>
      <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
      <span class="hljs-keyword">if</span> (addHour) {
        now.setHours(now.getHours() + <span class="hljs-number">1</span>);
      }
      <span class="hljs-keyword">return</span> formatDateForInput(now);
    }

    <span class="hljs-keyword">if</span> (addHour) {
      date.setHours(date.getHours() + <span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">return</span> formatDateForInput(date);
  } <span class="hljs-keyword">catch</span> {
    <span class="hljs-comment">// Fallback to current time if any error occurs</span>
    <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
    <span class="hljs-keyword">if</span> (addHour) {
      now.setHours(now.getHours() + <span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">return</span> formatDateForInput(now);
  }
};

<span class="hljs-keyword">interface</span> EventModalProps {
  <span class="hljs-attr">isOpen</span>: <span class="hljs-built_in">boolean</span>;
  onClose: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
  onSubmit: <span class="hljs-function">(<span class="hljs-params">eventData: { title: <span class="hljs-built_in">string</span>; start: <span class="hljs-built_in">string</span>; end: <span class="hljs-built_in">string</span> }</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
  onDelete?: <span class="hljs-function">(<span class="hljs-params">eventId: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
  dateStr: <span class="hljs-built_in">string</span>;
  event: {
    id?: <span class="hljs-built_in">any</span>; <span class="hljs-comment">// Convex ID type</span>
    title: <span class="hljs-built_in">string</span>;
    start: <span class="hljs-built_in">string</span>;
    end?: <span class="hljs-built_in">string</span>;
    creatorName?: <span class="hljs-built_in">string</span>;
  } | <span class="hljs-literal">null</span>;
  userId: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Add userId to props for checking user&#x27;s events</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> EventModal: React.FC&lt;EventModalProps&gt; = <span class="hljs-function">(<span class="hljs-params">{
  isOpen,
  onClose,
  onSubmit,
  onDelete,
  dateStr,
  event,
  userId,
}</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> [title, setTitle] = React.useState(<span class="hljs-string">&quot;&quot;</span>);
  <span class="hljs-keyword">const</span> [startDate, setStartDate] = React.useState(<span class="hljs-function">() =&gt;</span>
    getInitialDate(dateStr)
  );
  <span class="hljs-keyword">const</span> [endDate, setEndDate] = React.useState(<span class="hljs-function">() =&gt;</span>
    getInitialDate(dateStr, <span class="hljs-literal">true</span>)
  );
  <span class="hljs-keyword">const</span> [error, setError] = React.useState&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [isDeleting, setIsDeleting] = React.useState(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [overlappingSession, setOverlappingSession] = useState&lt;<span class="hljs-built_in">any</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// Get user&#x27;s existing events to check for overlaps</span>
  <span class="hljs-keyword">const</span> userEvents = useQuery(api.events.getByUserId, { userId }) || [];

  <span class="hljs-comment">// Check for overlapping sessions</span>
  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!isOpen || !userId || !startDate || !endDate) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> newStart = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(startDate).getTime();
      <span class="hljs-keyword">const</span> newEnd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(endDate).getTime();
      
      <span class="hljs-comment">// Reset overlap state</span>
      setOverlappingSession(<span class="hljs-literal">null</span>);

      <span class="hljs-comment">// Check each existing event for overlap</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> existingEvent <span class="hljs-keyword">of</span> userEvents) {
        <span class="hljs-comment">// Skip the current event being edited</span>
        <span class="hljs-keyword">if</span> (event &amp;&amp; existingEvent._id === event.id) <span class="hljs-keyword">continue</span>;
        
        <span class="hljs-keyword">const</span> existingStart = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(existingEvent.start).getTime();
        <span class="hljs-keyword">const</span> existingEnd = existingEvent.end 
          ? <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(existingEvent.end).getTime() 
          : existingStart + <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>; <span class="hljs-comment">// Default to 1 hour if no end time</span>
        
        <span class="hljs-comment">// Check for overlap</span>
        <span class="hljs-keyword">const</span> overlap = (newStart &gt;= existingStart &amp;&amp; newStart &lt; existingEnd) || 
                        (newEnd &gt; existingStart &amp;&amp; newEnd &lt;= existingEnd) ||
                        (newStart &lt;= existingStart &amp;&amp; newEnd &gt;= existingEnd);
        
        <span class="hljs-keyword">if</span> (overlap) {
          setOverlappingSession(existingEvent);
          <span class="hljs-keyword">break</span>;
        }
      }
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Error checking for overlapping sessions:&quot;</span>, error);
    }
  }, [isOpen, userEvents, startDate, endDate, userId, event]);

  <span class="hljs-comment">// Reset form when modal opens</span>
  React.useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (isOpen) {
      setError(<span class="hljs-literal">null</span>);
      setOverlappingSession(<span class="hljs-literal">null</span>);
      <span class="hljs-keyword">if</span> (event) {
        setTitle(event.title);
        setStartDate(getInitialDate(event.start));
        setEndDate(getInitialDate(event.end || event.start));
      } <span class="hljs-keyword">else</span> {
        setTitle(<span class="hljs-string">&quot;&quot;</span>);
        setStartDate(getInitialDate(dateStr));
        setEndDate(getInitialDate(dateStr, <span class="hljs-literal">true</span>));
      }
    }
  }, [dateStr, isOpen, event]);

  <span class="hljs-keyword">if</span> (!isOpen) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">const</span> handleSubmit = <span class="hljs-function">(<span class="hljs-params">e: React.FormEvent</span>) =&gt;</span> {
    e.preventDefault();
    <span class="hljs-keyword">try</span> {
      setError(<span class="hljs-literal">null</span>);
      <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(startDate);
      <span class="hljs-keyword">const</span> end = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(endDate);
      <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();

      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;EventModal - Form Submission:&quot;</span>, {
        title,
        start,
        end,
        now,
        <span class="hljs-attr">isPastDate</span>: start &lt; now
      });

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(start.getTime()) || <span class="hljs-built_in">isNaN</span>(end.getTime())) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;EventModal - Invalid date format detected&quot;</span>);
        <span class="hljs-keyword">const</span> errorMsg = <span class="hljs-string">&quot;Invalid date format. Please check your input.&quot;</span>;
        setError(errorMsg);
        showToast.error(errorMsg);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(errorMsg);
      }

      <span class="hljs-comment">// Check if start date is in the past</span>
      <span class="hljs-keyword">if</span> (start &lt; now) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;EventModal - Rejected: Past date detected&quot;</span>);
        setError(<span class="hljs-string">&quot;Cannot create session with a past date. Please select a future date.&quot;</span>);
        showToast.session.pastDateError();
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-comment">// Check for overlapping sessions</span>
      <span class="hljs-keyword">if</span> (overlappingSession) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;EventModal - Rejected: Overlapping session detected&quot;</span>, overlappingSession);
        <span class="hljs-keyword">const</span> errorMsg = <span class="hljs-string">`This session overlaps with your existing session &quot;<span class="hljs-subst">${overlappingSession.title}</span>&quot;`</span>;
        setError(errorMsg);
        showToast.session.overlapError();
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;EventModal - Submitting form:&quot;</span>, {
        title,
        <span class="hljs-attr">start</span>: start.toISOString(),
        <span class="hljs-attr">end</span>: end.toISOString(),
        <span class="hljs-attr">isEdit</span>: !!event
      });

      <span class="hljs-keyword">const</span> eventData = {
        title,
        <span class="hljs-attr">start</span>: start.toISOString(),
        <span class="hljs-attr">end</span>: end.toISOString(),
      };

      <span class="hljs-comment">// We need to use a Promise for async handling</span>
      onSubmit(eventData)
        .then(<span class="hljs-function">() =&gt;</span> {
          setTitle(<span class="hljs-string">&quot;&quot;</span>);
          onClose();
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;EventModal - Form submitted successfully&quot;</span>);
          <span class="hljs-comment">// Toast notifications are handled in the Calendar component</span>
        })
        .catch(<span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
          <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;EventModal - Error from backend:&quot;</span>, err);
          setError(err.message || <span class="hljs-string">&quot;Failed to create/update session. Please try again.&quot;</span>);
          <span class="hljs-comment">// Toast notifications for backend errors are handled in the Calendar component</span>
        });
    } <span class="hljs-keyword">catch</span> (error: <span class="hljs-built_in">any</span>) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;EventModal - Error processing dates:&quot;</span>, error);
      setError(error.message || <span class="hljs-string">&quot;Invalid date format. Please check your input.&quot;</span>);
    }
  };

  <span class="hljs-keyword">const</span> handleDelete = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">if</span> (!event?.id || !onDelete) <span class="hljs-keyword">return</span>;
    
    <span class="hljs-keyword">try</span> {
      setIsDeleting(<span class="hljs-literal">true</span>);
      setError(<span class="hljs-literal">null</span>);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;EventModal - Deleting session:&quot;</span>, event.id);
      
      <span class="hljs-keyword">await</span> onDelete(event.id);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;EventModal - Session deleted successfully&quot;</span>);
      
      onClose();
      <span class="hljs-comment">// Toast notification handled in Calendar component</span>
    } <span class="hljs-keyword">catch</span> (error: <span class="hljs-built_in">any</span>) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;EventModal - Error deleting session:&quot;</span>, error);
      <span class="hljs-keyword">const</span> errorMsg = error.message || <span class="hljs-string">&quot;Failed to delete session. Please try again.&quot;</span>;
      setError(errorMsg);
      showToast.error(errorMsg);
      setIsDeleting(<span class="hljs-literal">false</span>);
    }
  };

  <span class="hljs-keyword">const</span> handleDeleteConfirm = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.confirm(<span class="hljs-string">&quot;Are you sure you want to delete this session? This action cannot be undone.&quot;</span>)) {
      handleDelete();
    }
  };

  <span class="hljs-keyword">const</span> isValidDateRange = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(startDate) &lt; <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(endDate);
  <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  <span class="hljs-keyword">const</span> minDateTimeValue = formatDateForInput(now);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.modalOverlay}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.modal}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{event ? &quot;Edit Session&quot; : &quot;Create New Session&quot;}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        {error &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.errorMessage}</span>&gt;</span>{error}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}
        {overlappingSession &amp;&amp; (
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.warningMessage}</span>&gt;</span>
            Warning: This session overlaps with your existing session &quot;{overlappingSession.title}&quot;
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        )}
        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{handleSubmit}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.formGroup}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">htmlFor</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>Session Title<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
              <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>
              <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>
              <span class="hljs-attr">value</span>=<span class="hljs-string">{title}</span>
              <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setTitle(e.target.value)}
              placeholder=&quot;Enter session title&quot;
              autoFocus
              required
            /&gt;
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.formGroup}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">htmlFor</span>=<span class="hljs-string">&quot;startDate&quot;</span>&gt;</span>Start Date &amp; Time<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
              <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;startDate&quot;</span>
              <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;datetime-local&quot;</span>
              <span class="hljs-attr">value</span>=<span class="hljs-string">{startDate}</span>
              <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setStartDate(e.target.value)}
              min={!event ? minDateTimeValue : undefined}
              required
            /&gt;
            {new Date(startDate) &lt; now &amp;&amp; !event &amp;&amp; (
              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.errorMessage}</span>&gt;</span>
                Start time cannot be in the past
              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            )}
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.formGroup}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">htmlFor</span>=<span class="hljs-string">&quot;endDate&quot;</span>&gt;</span>End Date &amp; Time<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
              <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;endDate&quot;</span>
              <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;datetime-local&quot;</span>
              <span class="hljs-attr">value</span>=<span class="hljs-string">{endDate}</span>
              <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setEndDate(e.target.value)}
              min={startDate}
              required
            /&gt;
            {!isValidDateRange &amp;&amp; (
              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.errorMessage}</span>&gt;</span>
                End time must be after start time
              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            )}
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.buttonGroup}</span>&gt;</span>
            {event &amp;&amp; onDelete &amp;&amp; (
              <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
                <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>
                <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleDeleteConfirm}</span>
                <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.deleteButton}</span>
                <span class="hljs-attr">disabled</span>=<span class="hljs-string">{isDeleting}</span>
              &gt;</span>
                {isDeleting ? &quot;Deleting...&quot; : &quot;Delete Session&quot;}
              <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            )}
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.rightButtons}</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
                <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>
                <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onClose}</span>
                <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.cancelButton}</span>
              &gt;</span>
                Cancel
              <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
                <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>
                <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.submitButton}</span>
                <span class="hljs-attr">disabled</span>=<span class="hljs-string">{!title.trim()</span> || !<span class="hljs-attr">isValidDateRange</span> || <span class="hljs-attr">overlappingSession</span> !== <span class="hljs-string">null}</span>
              &gt;</span>
                {event ? &quot;Update Session&quot; : &quot;Create Session&quot;}
              <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

</code></pre>
<h4 id=src\components\calendar\indexts anchor=true>src\components\calendar\indexts</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">export</span> { Calendar } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Calendar&quot;</span>;

</code></pre>
<h4 id=src\components\calendar\SessionDetailsModaltsx anchor=true>src\components\calendar\SessionDetailsModaltsx</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> React, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { useNavigate } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./SessionDetailsModal.module.css&quot;</span>;
<span class="hljs-keyword">import</span> { showToast } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../utils/toast&quot;</span>;

<span class="hljs-comment">// Constants</span>
<span class="hljs-keyword">const</span> EARLY_JOIN_MINUTES = <span class="hljs-number">10</span>;

<span class="hljs-keyword">interface</span> SessionDetailsModalProps {
  <span class="hljs-attr">isOpen</span>: <span class="hljs-built_in">boolean</span>;
  onClose: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
  event: {
    <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;
    start: <span class="hljs-built_in">string</span>;
    end: <span class="hljs-built_in">string</span>;
    creatorName: <span class="hljs-built_in">string</span>;
    id: <span class="hljs-built_in">string</span>;
  } | <span class="hljs-literal">null</span>;
  isOwnEvent?: <span class="hljs-built_in">boolean</span>;
  onEdit?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SessionDetailsModal: React.FC&lt;SessionDetailsModalProps&gt; = <span class="hljs-function">(<span class="hljs-params">{
  isOpen,
  onClose,
  event,
  isOwnEvent = <span class="hljs-literal">false</span>,
  onEdit,
}</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> navigate = useNavigate();
  <span class="hljs-keyword">const</span> [currentTime, setCurrentTime] = useState(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());
  <span class="hljs-keyword">const</span> [canEnterSession, setCanEnterSession] = useState(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [sessionStatus, setSessionStatus] = useState&lt;<span class="hljs-string">&#x27;upcoming&#x27;</span> | <span class="hljs-string">&#x27;active&#x27;</span> | <span class="hljs-string">&#x27;ended&#x27;</span> | <span class="hljs-string">&#x27;early&#x27;</span>&gt;(<span class="hljs-string">&#x27;upcoming&#x27;</span>);
  <span class="hljs-keyword">const</span> [timeRemaining, setTimeRemaining] = useState(<span class="hljs-string">&#x27;&#x27;</span>);

  <span class="hljs-comment">// Update current time every second</span>
  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!isOpen) <span class="hljs-keyword">return</span>;
    
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      setCurrentTime(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());
    }, <span class="hljs-number">1000</span>);
    
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);
  }, [isOpen]);

  <span class="hljs-comment">// Check if user can enter the session</span>
  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!event) <span class="hljs-keyword">return</span>;
    
    <span class="hljs-keyword">const</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(event.start);
    <span class="hljs-keyword">const</span> endTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(event.end);
    <span class="hljs-keyword">const</span> now = currentTime;
    
    <span class="hljs-comment">// Calculate time until session starts</span>
    <span class="hljs-keyword">const</span> timeUntilStart = startTime.getTime() - now.getTime();
    <span class="hljs-keyword">const</span> earlyJoinThreshold = EARLY_JOIN_MINUTES * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>; <span class="hljs-comment">// 10 minutes in milliseconds</span>
    
    <span class="hljs-keyword">if</span> (timeUntilStart &gt; earlyJoinThreshold) {
      <span class="hljs-comment">// Session starts in more than 10 minutes - cannot join yet</span>
      setSessionStatus(<span class="hljs-string">&#x27;upcoming&#x27;</span>);
      setCanEnterSession(<span class="hljs-literal">false</span>);
      
      <span class="hljs-comment">// Format time remaining</span>
      <span class="hljs-keyword">const</span> hours = <span class="hljs-built_in">Math</span>.floor(timeUntilStart / (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>));
      <span class="hljs-keyword">const</span> minutes = <span class="hljs-built_in">Math</span>.floor((timeUntilStart % (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>)) / (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span>));
      <span class="hljs-keyword">const</span> seconds = <span class="hljs-built_in">Math</span>.floor((timeUntilStart % (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span>)) / <span class="hljs-number">1000</span>);
      
      <span class="hljs-keyword">if</span> (hours &gt; <span class="hljs-number">0</span>) {
        setTimeRemaining(<span class="hljs-string">`<span class="hljs-subst">${hours}</span>h <span class="hljs-subst">${minutes}</span>m <span class="hljs-subst">${seconds}</span>s`</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minutes &gt; <span class="hljs-number">0</span>) {
        setTimeRemaining(<span class="hljs-string">`<span class="hljs-subst">${minutes}</span>m <span class="hljs-subst">${seconds}</span>s`</span>);
      } <span class="hljs-keyword">else</span> {
        setTimeRemaining(<span class="hljs-string">`<span class="hljs-subst">${seconds}</span>s`</span>);
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timeUntilStart &gt; <span class="hljs-number">0</span> &amp;&amp; timeUntilStart &lt;= earlyJoinThreshold) {
      <span class="hljs-comment">// Within early join window (10 minutes before start)</span>
      setSessionStatus(<span class="hljs-string">&#x27;early&#x27;</span>);
      setCanEnterSession(<span class="hljs-literal">true</span>);
      
      <span class="hljs-keyword">const</span> minutesUntilStart = <span class="hljs-built_in">Math</span>.ceil(timeUntilStart / (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span>));
      setTimeRemaining(<span class="hljs-string">`<span class="hljs-subst">${minutesUntilStart}</span>m`</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (now &gt; endTime) {
      <span class="hljs-comment">// Session has ended</span>
      setSessionStatus(<span class="hljs-string">&#x27;ended&#x27;</span>);
      setCanEnterSession(<span class="hljs-literal">false</span>);
      setTimeRemaining(<span class="hljs-string">&#x27;&#x27;</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Session is active</span>
      setSessionStatus(<span class="hljs-string">&#x27;active&#x27;</span>);
      setCanEnterSession(<span class="hljs-literal">true</span>);
      setTimeRemaining(<span class="hljs-string">&#x27;&#x27;</span>);
    }
  }, [event, currentTime]);

  <span class="hljs-keyword">if</span> (!isOpen || !event) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

  <span class="hljs-comment">// Format dates for display</span>
  <span class="hljs-keyword">const</span> startDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(event.start).toLocaleString();
  <span class="hljs-keyword">const</span> endDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(event.end).toLocaleString();

  <span class="hljs-keyword">const</span> handleEnterSession = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!canEnterSession) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Cannot enter session yet - not time&quot;</span>);
      showToast.error(<span class="hljs-string">&quot;Cannot enter session yet. Please wait until the scheduled time.&quot;</span>);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Show appropriate toast based on session status</span>
    <span class="hljs-keyword">if</span> (sessionStatus === <span class="hljs-string">&#x27;early&#x27;</span>) {
      <span class="hljs-keyword">const</span> minutesEarly = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">Number</span>(timeRemaining.replace(<span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)));
      showToast.session.earlyJoin(minutesEarly);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sessionStatus === <span class="hljs-string">&#x27;active&#x27;</span>) {
      showToast.session.joined();
    }

    navigate(<span class="hljs-string">`/session/<span class="hljs-subst">${event.id}</span>`</span>);
    onClose();
  };

  <span class="hljs-keyword">const</span> getButtonLabel = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (sessionStatus === <span class="hljs-string">&#x27;early&#x27;</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">`Enter Session Early (Starts in <span class="hljs-subst">${timeRemaining}</span>)`</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sessionStatus === <span class="hljs-string">&#x27;active&#x27;</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Enter Session&quot;</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sessionStatus === <span class="hljs-string">&#x27;ended&#x27;</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Session Has Ended&quot;</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Session Not Started Yet&quot;</span>;
    }
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.modalOverlay}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onClose}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.modal}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{(e)</span> =&gt;</span> e.stopPropagation()}&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.modalHeader}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Session Details<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onClose}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.closeButton}</span>&gt;</span>
            <span class="hljs-symbol">&amp;times;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.modalContent}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.detailRow}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Title:<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{event.title}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.detailRow}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Created by:<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{event.creatorName}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.detailRow}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Start Time:<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{startDate}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.detailRow}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>End Time:<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{endDate}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.detailRow}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Status:<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles[sessionStatus]}</span>&gt;</span>
              {sessionStatus === &#x27;upcoming&#x27; &amp;&amp; (
                <span class="hljs-tag">&lt;&gt;</span>
                  Upcoming (Starts in {timeRemaining})
                <span class="hljs-tag">&lt;/&gt;</span>
              )}
              {sessionStatus === &#x27;early&#x27; &amp;&amp; (
                <span class="hljs-tag">&lt;&gt;</span>
                  Starting Soon (Join {timeRemaining} early)
                <span class="hljs-tag">&lt;/&gt;</span>
              )}
              {sessionStatus === &#x27;active&#x27; &amp;&amp; &#x27;Active Now&#x27;}
              {sessionStatus === &#x27;ended&#x27; &amp;&amp; &#x27;Session Ended&#x27;}
            <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.modalFooter}</span>&gt;</span>
          {sessionStatus === &#x27;upcoming&#x27; ? (
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.disabledButton}</span>&gt;</span>
              Session not started yet
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
          ) : sessionStatus === &#x27;ended&#x27; ? (
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.disabledButton}</span>&gt;</span>
              Session has ended
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
          ) : (
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
              <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleEnterSession}</span> 
              <span class="hljs-attr">className</span>=<span class="hljs-string">{sessionStatus</span> === <span class="hljs-string">&#x27;early&#x27;</span> ? <span class="hljs-attr">styles.earlyButton</span> <span class="hljs-attr">:</span> <span class="hljs-attr">styles.enterButton</span>}
            &gt;</span>
              {getButtonLabel()}
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
          )}
          {isOwnEvent &amp;&amp; onEdit &amp;&amp; (
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onEdit}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.editButton}</span>&gt;</span>
              Edit Session
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
          )}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

</code></pre>
<h4 id=src\components\layout\Headertsx anchor=true>src\components\layout\Headertsx</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { useState, useRef, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { useUser } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@clerk/clerk-react&quot;</span>;
<span class="hljs-keyword">import</span> { SignOutButton } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@clerk/clerk-react&quot;</span>;
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Header.module.css&quot;</span>;

<span class="hljs-keyword">interface</span> HeaderProps {}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Header = <span class="hljs-function">(<span class="hljs-params">{}: HeaderProps</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { isLoaded, isSignedIn, user } = useUser();
  <span class="hljs-keyword">const</span> [isDropdownOpen, setIsDropdownOpen] = useState(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> dropdownRef = useRef&lt;HTMLDivElement&gt;(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">const</span> toggleDropdown = <span class="hljs-function">() =&gt;</span> {
    setIsDropdownOpen(!isDropdownOpen);
  };

  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> handleClickOutside = <span class="hljs-function">(<span class="hljs-params">event: MouseEvent</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (
        dropdownRef.current &amp;&amp;
        !dropdownRef.current.contains(event.target <span class="hljs-keyword">as</span> Node)
      ) {
        setIsDropdownOpen(<span class="hljs-literal">false</span>);
      }
    };

    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;mousedown&quot;</span>, handleClickOutside);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">&quot;mousedown&quot;</span>, handleClickOutside);
    };
  }, []);

  <span class="hljs-keyword">let</span> displayUsername: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">if</span> (isLoaded &amp;&amp; isSignedIn &amp;&amp; user) {
    displayUsername = user.username ||
                      (user.firstName &amp;&amp; user.lastName ?
                        <span class="hljs-string">`<span class="hljs-subst">${user.firstName}</span> <span class="hljs-subst">${user.lastName}</span>`</span> :
                        user.emailAddresses?.[<span class="hljs-number">0</span>]?.emailAddress || <span class="hljs-string">&#x27;user&#x27;</span>);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isLoaded &amp;&amp; !isSignedIn) {
    displayUsername = <span class="hljs-string">&quot;Guest&quot;</span>;
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.header}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Workoutmate<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.userProfile}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.profileContainer}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{toggleDropdown}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.profileIcon}</span>&gt;</span>
            {displayUsername ? displayUsername.charAt(0).toUpperCase() : &quot;U&quot;}
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        {isDropdownOpen &amp;&amp; (
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{dropdownRef}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.profileDropdown}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.dropdownUserInfo}</span>&gt;</span>{displayUsername}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            {isSignedIn &amp;&amp; (
              <span class="hljs-tag">&lt;<span class="hljs-name">SignOutButton</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.dropdownItem}</span>&gt;</span>
                  Sign Out
                <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
              <span class="hljs-tag">&lt;/<span class="hljs-name">SignOutButton</span>&gt;</span>
            )}
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        )}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span>
  );
};

</code></pre>
<h4 id=src\components\layout\indexts anchor=true>src\components\layout\indexts</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">export</span> { Header } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Header&quot;</span>;

</code></pre>
<h4 id=src\components\messaging\Chattsx anchor=true>src\components\messaging\Chattsx</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { useQuery } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/react&quot;</span>;
<span class="hljs-keyword">import</span> { api } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../../convex/_generated/api&quot;</span>;
<span class="hljs-keyword">import</span> { useAuth } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../contexts/AuthContext&quot;</span>;
<span class="hljs-keyword">import</span> { Header } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../layout&quot;</span>;
<span class="hljs-keyword">import</span> { MessageInput } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./MessageInput&quot;</span>;
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Chat.module.css&quot;</span>;

<span class="hljs-keyword">interface</span> ChatProps {
  <span class="hljs-attr">userId</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
  username: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Chat = <span class="hljs-function">(<span class="hljs-params">{ userId, username }: ChatProps</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> messages = useQuery(api.chat.getMessages);

  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Make sure scrollTo works on button click in Chrome</span>
    <span class="hljs-keyword">if</span> (messages) {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">window</span>.scrollTo({ <span class="hljs-attr">top</span>: <span class="hljs-built_in">document</span>.body.scrollHeight, <span class="hljs-attr">behavior</span>: <span class="hljs-string">&quot;smooth&quot;</span> });
      }, <span class="hljs-number">0</span>);
    }
  }, [messages]);

  <span class="hljs-comment">// Since ProtectedRoute ensures we always have a username, we can safely assert it&#x27;s non-null</span>
  <span class="hljs-keyword">const</span> userDisplayName = username <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.chatContainer}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> <span class="hljs-attr">username</span>=<span class="hljs-string">{userDisplayName}</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.chat}</span>&gt;</span>
        {messages?.map((message) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">article</span>
            <span class="hljs-attr">key</span>=<span class="hljs-string">{message._id}</span>
            <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">styles.messageArticle</span>} ${<span class="hljs-attr">message.user</span> === <span class="hljs-string">userDisplayName</span> ? <span class="hljs-attr">styles.messageMine</span> <span class="hljs-attr">:</span> &quot;&quot;}`}
          &gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{message.user}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{message.body}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">MessageInput</span> <span class="hljs-attr">username</span>=<span class="hljs-string">{userDisplayName}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}; 
</code></pre>
<h4 id=src\components\messaging\indexts anchor=true>src\components\messaging\indexts</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">export</span> { Chat } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Chat&quot;</span>;
<span class="hljs-keyword">export</span> { MessageInput } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./MessageInput&quot;</span>;
<span class="hljs-keyword">export</span> { SessionChat } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./SessionChat&quot;</span>;

</code></pre>
<h4 id=src\components\messaging\MessageInputtsx anchor=true>src\components\messaging\MessageInputtsx</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { useMutation } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/react&quot;</span>;
<span class="hljs-keyword">import</span> { api } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../../convex/_generated/api&quot;</span>;
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./MessageInput.module.css&quot;</span>;

<span class="hljs-keyword">interface</span> MessageInputProps {
  <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span>;
  sessionId?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Make sessionId optional for backward compatibility</span>
  disabled?: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// Add optional disabled prop</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> MessageInput = <span class="hljs-function">(<span class="hljs-params">{ username, sessionId, disabled = <span class="hljs-literal">false</span> }: MessageInputProps</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> sendMessage = useMutation(api.chat.sendMessage);
  <span class="hljs-keyword">const</span> [newMessageText, setNewMessageText] = useState(<span class="hljs-string">&quot;&quot;</span>);

  <span class="hljs-keyword">const</span> handleSubmit = <span class="hljs-keyword">async</span> (e: React.FormEvent) =&gt; {
    e.preventDefault();
    <span class="hljs-keyword">if</span> (disabled) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">await</span> sendMessage({
      <span class="hljs-attr">user</span>: username,
      <span class="hljs-attr">body</span>: newMessageText,
      sessionId,
    });
    setNewMessageText(<span class="hljs-string">&quot;&quot;</span>);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{handleSubmit}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.form}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
        <span class="hljs-attr">value</span>=<span class="hljs-string">{newMessageText}</span>
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setNewMessageText(e.target.value)}
        placeholder={disabled ? &quot;Log in to chat&quot; : &quot;Write a message…&quot;}
        autoFocus
        className={styles.input}
        disabled={disabled} // Apply disabled prop
      /&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>
        <span class="hljs-attr">disabled</span>=<span class="hljs-string">{!newMessageText</span> || <span class="hljs-attr">disabled</span>} // <span class="hljs-attr">Apply</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">prop</span> <span class="hljs-attr">here</span> <span class="hljs-attr">too</span>
        <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.button}</span>
      &gt;</span>
        Send
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>
  );
};

</code></pre>
<h4 id=src\components\messaging\SessionChattsx anchor=true>src\components\messaging\SessionChattsx</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { useState, useEffect, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { useParams } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;
<span class="hljs-keyword">import</span> { useQuery, useMutation } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/react&quot;</span>;
<span class="hljs-keyword">import</span> { useUser } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@clerk/clerk-react&quot;</span>;
<span class="hljs-keyword">import</span> { api } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../convex&quot;</span>;
<span class="hljs-keyword">import</span> { MessageInput } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./MessageInput&quot;</span>;
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Chat.module.css&quot;</span>;

<span class="hljs-keyword">interface</span> SessionChatProps {}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SessionChat</span>(<span class="hljs-params">{}: SessionChatProps</span>) </span>{
  <span class="hljs-keyword">const</span> { sessionId } = useParams&lt;{ <span class="hljs-attr">sessionId</span>: <span class="hljs-built_in">string</span> }&gt;();
  <span class="hljs-keyword">const</span> chatContainerRef = useRef&lt;HTMLDivElement&gt;(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// Get auth state and user details from Clerk</span>
  <span class="hljs-keyword">const</span> { isLoaded, isSignedIn, user } = useUser();

  <span class="hljs-comment">// Derive userId and username</span>
  <span class="hljs-keyword">const</span> currentUsername = isLoaded &amp;&amp; isSignedIn &amp;&amp; user ? 
                          user.username || 
                          (user.firstName &amp;&amp; user.lastName ? 
                            <span class="hljs-string">`<span class="hljs-subst">${user.firstName}</span> <span class="hljs-subst">${user.lastName}</span>`</span> : 
                            user.emailAddresses?.[<span class="hljs-number">0</span>]?.emailAddress || <span class="hljs-string">&#x27;user&#x27;</span>) 
                          : <span class="hljs-string">&quot;&quot;</span>;

  <span class="hljs-comment">// Get session details</span>
  <span class="hljs-keyword">const</span> session = useQuery(api.events.getEventById, { <span class="hljs-attr">id</span>: sessionId || <span class="hljs-string">&quot;&quot;</span> });
  <span class="hljs-comment">// Use session-specific messages instead of all messages</span>
  <span class="hljs-keyword">const</span> messages = useQuery(api.chat.getSessionMessages, {
    <span class="hljs-attr">sessionId</span>: sessionId || <span class="hljs-string">&quot;&quot;</span>,
  });

  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Scroll to bottom when messages change</span>
    <span class="hljs-keyword">if</span> (messages &amp;&amp; chatContainerRef.current) {
      chatContainerRef.current.scrollTop =
        chatContainerRef.current.scrollHeight;
    }
  }, [messages]);

  <span class="hljs-keyword">if</span> (!session) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading session information...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.chatContainer}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.chat}</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{chatContainerRef}</span>&gt;</span>
        {messages?.length === 0 ? (
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.emptyState}</span>&gt;</span>
            No messages yet. Start the conversation!
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        ) : (
          messages?.map((message) =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-name">article</span>
              <span class="hljs-attr">key</span>=<span class="hljs-string">{message._id}</span>
              <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">styles.messageArticle</span>} ${<span class="hljs-attr">message.user</span> === <span class="hljs-string">currentUsername</span> ? <span class="hljs-attr">styles.messageMine</span> <span class="hljs-attr">:</span> &quot;&quot;}`}
            &gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{message.user}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{message.body}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>
          ))
        )}
      <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.inputContainer}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">MessageInput</span> 
          <span class="hljs-attr">username</span>=<span class="hljs-string">{currentUsername}</span> 
          <span class="hljs-attr">sessionId</span>=<span class="hljs-string">{sessionId}</span> 
          <span class="hljs-attr">disabled</span>=<span class="hljs-string">{!isLoaded</span> || !<span class="hljs-attr">isSignedIn</span>} 
        /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

</code></pre>
<h4 id=src\components\session\indexts anchor=true>src\components\session\indexts</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">export</span> { Session } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Session&quot;</span>;
<span class="hljs-keyword">export</span> { VideoCall } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./VideoCall&quot;</span>;

</code></pre>
<h4 id=src\components\session\Sessiontsx anchor=true>src\components\session\Sessiontsx</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { useParams, useNavigate } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;
<span class="hljs-keyword">import</span> { useQuery, useMutation } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/react&quot;</span>;
<span class="hljs-keyword">import</span> { useUser } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@clerk/clerk-react&quot;</span>; 
<span class="hljs-keyword">import</span> { api } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../convex&quot;</span>;
<span class="hljs-keyword">import</span> { Header } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../layout&quot;</span>;
<span class="hljs-keyword">import</span> { SessionChat } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../messaging&quot;</span>;
<span class="hljs-keyword">import</span> { VideoCall } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./VideoCall&quot;</span>;
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Session.module.css&quot;</span>;
<span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { showToast } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../utils/toast&quot;</span>;

<span class="hljs-keyword">interface</span> SessionProps {}

<span class="hljs-keyword">interface</span> SessionStatus {
  <span class="hljs-attr">canJoin</span>: <span class="hljs-built_in">boolean</span>;
  message: <span class="hljs-built_in">string</span>;
  status: <span class="hljs-string">&#x27;upcoming&#x27;</span> | <span class="hljs-string">&#x27;active&#x27;</span> | <span class="hljs-string">&#x27;ended&#x27;</span> | <span class="hljs-string">&#x27;loading&#x27;</span> | <span class="hljs-string">&#x27;early&#x27;</span>;
  timeRemaining?: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Session</span>(<span class="hljs-params">{}: SessionProps</span>) </span>{
  <span class="hljs-keyword">const</span> { sessionId } = useParams&lt;{ <span class="hljs-attr">sessionId</span>: <span class="hljs-built_in">string</span> }&gt;();
  <span class="hljs-keyword">const</span> navigate = useNavigate();
  <span class="hljs-keyword">const</span> [sessionStatus, setSessionStatus] = useState&lt;SessionStatus&gt;({
    <span class="hljs-attr">canJoin</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Loading session information...&quot;</span>,
    <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;loading&#x27;</span>
  });
  <span class="hljs-keyword">const</span> [currentTime, setCurrentTime] = useState(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());
  <span class="hljs-keyword">const</span> [hasShownJoinToast, setHasShownJoinToast] = useState(<span class="hljs-literal">false</span>);

  <span class="hljs-comment">// Use Clerk&#x27;s useUser hook directly for auth state and user details</span>
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">isLoaded</span>: clerkLoaded, isSignedIn, user } = useUser();

  <span class="hljs-comment">// Mutation for joining the session</span>
  <span class="hljs-keyword">const</span> joinSessionMutation = useMutation(api.events.joinSession);

  <span class="hljs-comment">// Get session details</span>
  <span class="hljs-keyword">const</span> session = useQuery(api.events.getEventById, { <span class="hljs-attr">id</span>: sessionId || <span class="hljs-string">&quot;&quot;</span> });

  <span class="hljs-comment">// Update time every second</span>
  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      setCurrentTime(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());
    }, <span class="hljs-number">1000</span>);
    
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);
  }, []);

  <span class="hljs-comment">// Validate session timing</span>
  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Ensure session is loaded and is actually an event document</span>
    <span class="hljs-keyword">if</span> (!session || !(<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-keyword">in</span> session) || !(<span class="hljs-string">&quot;start&quot;</span> <span class="hljs-keyword">in</span> session)) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">const</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(session.start);
    <span class="hljs-keyword">const</span> endTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(session.end || session.start); <span class="hljs-comment">// Use start if end is missing</span>
    <span class="hljs-keyword">const</span> now = currentTime;

    <span class="hljs-comment">// Calculate time values</span>
    <span class="hljs-keyword">const</span> timeUntilStart = startTime.getTime() - now.getTime();
    <span class="hljs-keyword">const</span> earlyJoinThreshold = <span class="hljs-number">10</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>; <span class="hljs-comment">// 10 minutes in milliseconds</span>
    
    <span class="hljs-keyword">if</span> (timeUntilStart &gt; earlyJoinThreshold) {
      <span class="hljs-comment">// Session starts in more than 10 minutes - cannot join yet</span>
      <span class="hljs-comment">// Format time remaining</span>
      <span class="hljs-keyword">const</span> hours = <span class="hljs-built_in">Math</span>.floor(timeUntilStart / (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>));
      <span class="hljs-keyword">const</span> minutes = <span class="hljs-built_in">Math</span>.floor((timeUntilStart % (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>)) / (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span>));
      <span class="hljs-keyword">const</span> seconds = <span class="hljs-built_in">Math</span>.floor((timeUntilStart % (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span>)) / <span class="hljs-number">1000</span>);
      
      <span class="hljs-keyword">let</span> timeRemainingStr;
      <span class="hljs-keyword">if</span> (hours &gt; <span class="hljs-number">0</span>) {
        timeRemainingStr = <span class="hljs-string">`<span class="hljs-subst">${hours}</span>h <span class="hljs-subst">${minutes}</span>m <span class="hljs-subst">${seconds}</span>s`</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minutes &gt; <span class="hljs-number">0</span>) {
        timeRemainingStr = <span class="hljs-string">`<span class="hljs-subst">${minutes}</span>m <span class="hljs-subst">${seconds}</span>s`</span>;
      } <span class="hljs-keyword">else</span> {
        timeRemainingStr = <span class="hljs-string">`<span class="hljs-subst">${seconds}</span>s`</span>;
      }

      setSessionStatus({
        <span class="hljs-attr">canJoin</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">`This session hasn&#x27;t started yet. Please come back at the scheduled time.`</span>,
        <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;upcoming&#x27;</span>,
        <span class="hljs-attr">timeRemaining</span>: timeRemainingStr
      });
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timeUntilStart &gt; <span class="hljs-number">0</span> &amp;&amp; timeUntilStart &lt;= earlyJoinThreshold) {
      <span class="hljs-comment">// Within 10 minutes of start time - early join is allowed</span>
      <span class="hljs-keyword">const</span> minutesUntilStart = <span class="hljs-built_in">Math</span>.ceil(timeUntilStart / (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span>));
      
      setSessionStatus({
        <span class="hljs-attr">canJoin</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">`Session starts in <span class="hljs-subst">${minutesUntilStart}</span> minute<span class="hljs-subst">${minutesUntilStart !== <span class="hljs-number">1</span> ? <span class="hljs-string">&#x27;s&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>}</span>. You can join early to prepare.`</span>,
        <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;early&#x27;</span>,
        <span class="hljs-attr">timeRemaining</span>: <span class="hljs-string">`<span class="hljs-subst">${minutesUntilStart}</span>m`</span>
      });

      <span class="hljs-comment">// Show early join toast once</span>
      <span class="hljs-keyword">if</span> (!hasShownJoinToast) {
        showToast.session.earlyJoin(minutesUntilStart);
        setHasShownJoinToast(<span class="hljs-literal">true</span>);
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (now &gt; endTime) {
      <span class="hljs-comment">// Session has ended</span>
      setSessionStatus({
        <span class="hljs-attr">canJoin</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;This session has ended.&quot;</span>,
        <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;ended&#x27;</span>
      });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Session is active</span>
      setSessionStatus({
        <span class="hljs-attr">canJoin</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Session is active&quot;</span>,
        <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;active&#x27;</span>
      });

      <span class="hljs-comment">// Show joined toast once</span>
      <span class="hljs-keyword">if</span> (!hasShownJoinToast) {
        showToast.session.joined();
        setHasShownJoinToast(<span class="hljs-literal">true</span>);
      }
    }
  }, [session, currentTime, hasShownJoinToast]);

  <span class="hljs-comment">// Effect to join session when conditions are met</span>
  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Use clerkLoaded and isSignedIn for the check</span>
    <span class="hljs-keyword">if</span> (sessionStatus.canJoin &amp;&amp; sessionId &amp;&amp; clerkLoaded &amp;&amp; isSignedIn) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Attempting to join session (Clerk auth confirmed):&quot;</span>, sessionId);
      joinSessionMutation({ <span class="hljs-attr">eventId</span>: sessionId <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span> }) <span class="hljs-comment">// Cast to any if Id type causes issues</span>
        .then(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Successfully called joinSession mutation&quot;</span>);
        })
        .catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
          <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Error calling joinSession mutation:&quot;</span>, error);
          showToast.error(<span class="hljs-string">&quot;Failed to mark you as joined in the session.&quot;</span>);
        });
    }
  }, [sessionStatus.canJoin, sessionId, joinSessionMutation, clerkLoaded, isSignedIn]);

  <span class="hljs-comment">// Derive userId and username only if signed in and loaded</span>
  <span class="hljs-keyword">const</span> currentUserId = clerkLoaded &amp;&amp; isSignedIn &amp;&amp; user ? user.id : <span class="hljs-string">&quot;&quot;</span>;
  <span class="hljs-keyword">const</span> currentUsername = clerkLoaded &amp;&amp; isSignedIn &amp;&amp; user ? 
                          user.username || 
                          (user.firstName &amp;&amp; user.lastName ? 
                            <span class="hljs-string">`<span class="hljs-subst">${user.firstName}</span> <span class="hljs-subst">${user.lastName}</span>`</span> : 
                            user.emailAddresses?.[<span class="hljs-number">0</span>]?.emailAddress || <span class="hljs-string">&#x27;user&#x27;</span>) 
                          : <span class="hljs-string">&quot;&quot;</span>;

  <span class="hljs-comment">// If session data is still loading</span>
  <span class="hljs-keyword">if</span> (!session) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.sessionContainer}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.errorContainer}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.errorMessage}</span>&gt;</span>
            Loading session information...
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }

  <span class="hljs-comment">// If session timing is invalid, show error</span>
  <span class="hljs-keyword">if</span> (!sessionStatus.canJoin) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.sessionContainer}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.sessionHeader}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.backButton}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> navigate(-1)}&gt;
            ← Back
          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{session &amp;&amp; &#x27;title&#x27; in session ? session.title : &#x27;Session&#x27;}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.errorContainer}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.errorMessage}</span>&gt;</span>
            {sessionStatus.message}
            {sessionStatus.status === &#x27;upcoming&#x27; &amp;&amp; (
              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.timeRemaining}</span>&gt;</span>
                Starting in: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.countdown}</span>&gt;</span>{sessionStatus.timeRemaining}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            )}
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
            <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.actionButton}</span>
            <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> navigate(&#x27;/calendar&#x27;)}
          &gt;
            Return to Calendar
          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }

  <span class="hljs-comment">// Early join or active session - show a banner for early join</span>
  <span class="hljs-keyword">const</span> isEarlyJoin = sessionStatus.status === <span class="hljs-string">&#x27;early&#x27;</span>;

  <span class="hljs-comment">// Extract participant IDs, default to empty array</span>
  <span class="hljs-comment">// Ensure session is an event before accessing participantIds</span>
  <span class="hljs-keyword">const</span> participantIds = (session &amp;&amp; <span class="hljs-string">&quot;participantIds&quot;</span> <span class="hljs-keyword">in</span> session &amp;&amp; session.participantIds) ? session.participantIds : [];

  <span class="hljs-comment">// Log the participantIds being passed down on each render</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[Session.tsx] Rendering. Passing participantIds to VideoCall:`</span>, participantIds);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.sessionContainer}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.sessionHeader}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.backButton}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> navigate(-1)}&gt;
          ← Back
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{session &amp;&amp; &#x27;title&#x27; in session ? session.title : &#x27;Loading...&#x27;}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      
      {isEarlyJoin &amp;&amp; (
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.earlyJoinBanner}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.earlyJoinMessage}</span>&gt;</span>
            {sessionStatus.message}
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      )}

      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.sessionContent}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.mainArea}</span>&gt;</span>
          {/* Use clerkLoaded and isSignedIn for the render condition */}
          {clerkLoaded &amp;&amp; isSignedIn ? (
            <span class="hljs-tag">&lt;<span class="hljs-name">VideoCall</span>
              <span class="hljs-attr">sessionId</span>=<span class="hljs-string">{sessionId</span> || &quot;&quot;}
              <span class="hljs-attr">userId</span>=<span class="hljs-string">{currentUserId}</span>      // <span class="hljs-attr">Pass</span> <span class="hljs-attr">derived</span> <span class="hljs-attr">userId</span>
              <span class="hljs-attr">username</span>=<span class="hljs-string">{currentUsername}</span>  // <span class="hljs-attr">Pass</span> <span class="hljs-attr">derived</span> <span class="hljs-attr">username</span>
              <span class="hljs-attr">participantIds</span>=<span class="hljs-string">{participantIds}</span> 
            /&gt;</span>
          ) : (
            // Optionally show a loading state while auth checks
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Authenticating video call...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> 
          )}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.sidebarArea}</span>&gt;</span>
          {/* Remove userId and username props from SessionChat */}
          <span class="hljs-tag">&lt;<span class="hljs-name">SessionChat</span> /&gt;</span> 
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

</code></pre>
<h4 id=src\components\session\VideoCalltsx anchor=true>src\components\session\VideoCalltsx</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { useEffect, useRef, useState, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { useQuery, useMutation, useConvexAuth } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/react&quot;</span>;
<span class="hljs-keyword">import</span> { api } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../../convex/_generated/api&quot;</span>;
<span class="hljs-keyword">import</span> { Id, Doc } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../../convex/_generated/dataModel&quot;</span>;
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./VideoCall.module.css&quot;</span>;

<span class="hljs-comment">// Define the structure for peer connections</span>
<span class="hljs-keyword">interface</span> PeerConnection {
  <span class="hljs-attr">connection</span>: RTCPeerConnection;
  remoteStream?: MediaStream;
}

<span class="hljs-keyword">interface</span> VideoCallProps {
  <span class="hljs-attr">sessionId</span>: <span class="hljs-built_in">string</span>;
  userId: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Current user&#x27;s ID</span>
  username: <span class="hljs-built_in">string</span>;
  participantIds: <span class="hljs-built_in">string</span>[]; <span class="hljs-comment">// IDs of ALL participants including self</span>
}

<span class="hljs-comment">// Basic STUN server configuration (Google&#x27;s public servers)</span>
<span class="hljs-keyword">const</span> stunServers = {
  <span class="hljs-attr">iceServers</span>: [
    { <span class="hljs-attr">urls</span>: <span class="hljs-string">&quot;stun:stun.l.google.com:19302&quot;</span> },
    { <span class="hljs-attr">urls</span>: <span class="hljs-string">&quot;stun:stun1.l.google.com:19302&quot;</span> },
  ],
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> VideoCall = <span class="hljs-function">(<span class="hljs-params">{ sessionId, userId, username, participantIds }: VideoCallProps</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> [localStream, setLocalStream] = useState&lt;MediaStream | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [remoteStreams, setRemoteStreams] = useState&lt;Record&lt;<span class="hljs-built_in">string</span>, MediaStream&gt;&gt;({}); <span class="hljs-comment">// State to hold remote streams</span>
  <span class="hljs-keyword">const</span> localVideoRef = useRef&lt;HTMLVideoElement&gt;(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> remoteVideoRefs = useRef&lt;Record&lt;<span class="hljs-built_in">string</span>, HTMLVideoElement | <span class="hljs-literal">null</span>&gt;&gt;({}); <span class="hljs-comment">// Refs for remote video elements</span>
  <span class="hljs-keyword">const</span> pendingCandidatesRef = useRef&lt;Record&lt;<span class="hljs-built_in">string</span>, RTCIceCandidateInit[]&gt;&gt;({}); <span class="hljs-comment">// Ref to store pending candidates</span>
  <span class="hljs-keyword">const</span> peerConnections = useRef&lt;Record&lt;<span class="hljs-built_in">string</span>, RTCPeerConnection&gt;&gt;({}); <span class="hljs-comment">// Use useRef for peer connections</span>
  <span class="hljs-keyword">const</span> makingOffer = useRef&lt;Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>&gt;&gt;({}); <span class="hljs-comment">// Track makingOffer state</span>
  <span class="hljs-keyword">const</span> ignoreOffer = useRef&lt;Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>&gt;&gt;({}); <span class="hljs-comment">// Track ignoreOffer state</span>
  <span class="hljs-keyword">const</span> queuedIceCandidatesRef = useRef&lt;Record&lt;<span class="hljs-built_in">string</span>, RTCIceCandidate[]&gt;&gt;({}); <span class="hljs-comment">// Queue for early candidates</span>

  <span class="hljs-comment">// Convex Auth state</span>
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">isLoading</span>: isAuthLoading, isAuthenticated } = useConvexAuth();

  <span class="hljs-comment">// Convex mutations and queries</span>
  <span class="hljs-keyword">const</span> sendSignal = useMutation(api.video.sendSignal);
  <span class="hljs-keyword">const</span> deleteSignal = useMutation(api.video.deleteSignal);
  <span class="hljs-keyword">const</span> signals = useQuery(api.video.getSignals, isAuthenticated ? { sessionId } : <span class="hljs-string">&quot;skip&quot;</span>);

  <span class="hljs-keyword">const</span> otherParticipantIds = participantIds.filter(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> id !== userId);

  <span class="hljs-comment">// --- Initialize Local Media ---</span>
  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> startMedia = <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> stream = <span class="hljs-keyword">await</span> navigator.mediaDevices.getUserMedia({ <span class="hljs-attr">video</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">audio</span>: <span class="hljs-literal">true</span> });
        setLocalStream(stream);
        <span class="hljs-keyword">if</span> (localVideoRef.current) {
          localVideoRef.current.srcObject = stream;
        }
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Error accessing media devices:&quot;</span>, error);
        <span class="hljs-comment">// Handle error appropriately (e.g., show message to user)</span>
      }
    };
    startMedia();

    <span class="hljs-comment">// Cleanup</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      localStream?.getTracks().forEach(<span class="hljs-function">(<span class="hljs-params">track</span>) =&gt;</span> track.stop());
      <span class="hljs-built_in">Object</span>.values(peerConnections.current).forEach(<span class="hljs-function"><span class="hljs-params">pc</span> =&gt;</span> pc.close());
    };
    <span class="hljs-comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span>
  }, []); <span class="hljs-comment">// Run only once on mount</span>

  <span class="hljs-comment">// --- Create Peer Connection Function ---</span>
  <span class="hljs-keyword">const</span> createPeerConnection = useCallback((targetUserId: <span class="hljs-built_in">string</span>): RTCPeerConnection | <span class="hljs-function"><span class="hljs-params">null</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (!localStream) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Local stream not available to create peer connection.&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Creating peer connection to <span class="hljs-subst">${targetUserId}</span>`</span>);
    <span class="hljs-keyword">const</span> pc = <span class="hljs-keyword">new</span> RTCPeerConnection(stunServers);

    <span class="hljs-comment">// Add local tracks</span>
    localStream.getTracks().forEach(<span class="hljs-function">(<span class="hljs-params">track</span>) =&gt;</span> {
        pc.addTrack(track, localStream);
    });

    <span class="hljs-comment">// Triggered when the connection needs to negotiate (e.g., adding tracks)</span>
    pc.onnegotiationneeded = <span class="hljs-keyword">async</span> () =&gt; {
        <span class="hljs-comment">// Avoid negotiation for self or if connection is closing</span>
        <span class="hljs-keyword">if</span> (!userId || userId === targetUserId || pc.signalingState === <span class="hljs-string">&#x27;closed&#x27;</span>) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Skipping negotiation for <span class="hljs-subst">${targetUserId}</span> (self, closed, or no user)`</span>);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Negotiation needed with <span class="hljs-subst">${targetUserId}</span>, state: <span class="hljs-subst">${pc.signalingState}</span>`</span>);

        <span class="hljs-comment">// Perfect Negotiation: Check flags before creating offer</span>
        <span class="hljs-keyword">if</span> (makingOffer.current[targetUserId] || ignoreOffer.current[targetUserId]) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Negotiation needed for <span class="hljs-subst">${targetUserId}</span>, but making/ignore flag set. Skipping offer creation.`</span>);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// Only proceed if the state is stable (or potentially closed if we want to restart)</span>
        <span class="hljs-keyword">if</span> (pc.signalingState !== <span class="hljs-string">&#x27;stable&#x27;</span>) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Negotiation needed for <span class="hljs-subst">${targetUserId}</span>, but state is <span class="hljs-subst">${pc.signalingState}</span>. Skipping offer creation.`</span>);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Set flag before starting async operation</span>
            makingOffer.current[targetUserId] = <span class="hljs-literal">true</span>;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Setting local description (offer) for <span class="hljs-subst">${targetUserId}</span> via negotiationneeded.`</span>);
            <span class="hljs-keyword">const</span> offer = <span class="hljs-keyword">await</span> pc.createOffer();

            <span class="hljs-comment">// Double-check state *after* offer creation, *before* setting local desc</span>
            <span class="hljs-keyword">if</span> (pc.signalingState !== <span class="hljs-string">&#x27;stable&#x27;</span>) {
                <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`State changed during offer creation for <span class="hljs-subst">${targetUserId}</span> (now <span class="hljs-subst">${pc.signalingState}</span>). Aborting offer.`</span>);
                makingOffer.current[targetUserId] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Reset flag</span>
                <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">await</span> pc.setLocalDescription(offer);
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Local description (offer) set for <span class="hljs-subst">${targetUserId}</span>`</span>);

            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Sending offer to <span class="hljs-subst">${targetUserId}</span> via negotiationneeded`</span>);
            sendSignal({
                sessionId,
                <span class="hljs-attr">targetUserId</span>: targetUserId,
                <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;offer&quot;</span>,
                <span class="hljs-attr">signal</span>: <span class="hljs-built_in">JSON</span>.stringify({ <span class="hljs-attr">type</span>: pc.localDescription?.type, <span class="hljs-attr">sdp</span>: pc.localDescription?.sdp }),
            });
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`Error during negotiationneeded offer for <span class="hljs-subst">${targetUserId}</span>:`</span>, error);
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-comment">// Reset flag after operation completes or fails</span>
            <span class="hljs-comment">// Check if an incoming offer caused us to ignore ours before resetting</span>
            <span class="hljs-keyword">if</span> (!ignoreOffer.current[targetUserId]) {
                makingOffer.current[targetUserId] = <span class="hljs-literal">false</span>;
            }
        }
    };

    <span class="hljs-comment">// Handle incoming remote tracks</span>
    pc.ontrack = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Track received from <span class="hljs-subst">${targetUserId}</span>`</span>, event.streams[<span class="hljs-number">0</span>]);
      <span class="hljs-keyword">const</span> remoteStream = event.streams[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">if</span> (remoteStream) {
        setRemoteStreams(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> existingStream = prev[targetUserId];
          <span class="hljs-keyword">if</span> (existingStream) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Updating existing stream for <span class="hljs-subst">${targetUserId}</span>`</span>);
            event.track.onended = <span class="hljs-function">() =&gt;</span> {
              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Remote track ended for <span class="hljs-subst">${targetUserId}</span>`</span>);
              <span class="hljs-comment">// Optionally handle track ending, e.g., remove stream or track</span>
            };
            <span class="hljs-keyword">return</span> { ...prev, [targetUserId]: remoteStream }; 
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Creating new stream entry for <span class="hljs-subst">${targetUserId}</span>`</span>);
            event.track.onended = <span class="hljs-function">() =&gt;</span> {
              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Remote track ended for <span class="hljs-subst">${targetUserId}</span>`</span>);
              <span class="hljs-comment">// Optionally handle track ending</span>
            };
            <span class="hljs-keyword">return</span> { ...prev, [targetUserId]: remoteStream };
          }
        });
      }
    };

    <span class="hljs-comment">// Handle ICE candidates</span>
    pc.onicecandidate = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (event.candidate) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Sending ICE candidate to <span class="hljs-subst">${targetUserId}</span>`</span>);
        sendSignal({
          sessionId,
          targetUserId,
          <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;candidate&quot;</span>,
          <span class="hljs-attr">signal</span>: <span class="hljs-built_in">JSON</span>.stringify(event.candidate),
        });
      }
    };

    <span class="hljs-comment">// Handle connection state changes (optional but useful)</span>
    pc.onconnectionstatechange = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Connection state with <span class="hljs-subst">${targetUserId}</span>: <span class="hljs-subst">${pc.connectionState}</span>`</span>);
        <span class="hljs-comment">// Can update UI or handle disconnections here</span>
        <span class="hljs-keyword">if</span> (pc.connectionState === <span class="hljs-string">&#x27;disconnected&#x27;</span> || pc.connectionState === <span class="hljs-string">&#x27;failed&#x27;</span> || pc.connectionState === <span class="hljs-string">&#x27;closed&#x27;</span>) {
            <span class="hljs-comment">// Clean up connection for this peer</span>
             <span class="hljs-keyword">delete</span> peerConnections.current[targetUserId]; <span class="hljs-comment">// Use delete instead of assigning undefined</span>
        }
    };

    peerConnections.current[targetUserId] = pc;

    <span class="hljs-keyword">return</span> pc;
  }, [localStream, sendSignal, sessionId]); <span class="hljs-comment">// Dependencies</span>

  <span class="hljs-comment">// Helper function to process queued ICE candidates for a specific peer</span>
  <span class="hljs-keyword">const</span> processQueuedIceCandidates = useCallback(<span class="hljs-keyword">async</span> (peerId: <span class="hljs-built_in">string</span>) =&gt; {
    <span class="hljs-keyword">const</span> pc = peerConnections.current[peerId];
    <span class="hljs-keyword">const</span> queue = queuedIceCandidatesRef.current[peerId];

    <span class="hljs-comment">// Ensure PC exists, remote description is set, and there&#x27;s a queue with candidates</span>
    <span class="hljs-keyword">if</span> (pc &amp;&amp; pc.remoteDescription &amp;&amp; queue &amp;&amp; queue.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Processing <span class="hljs-subst">${queue.length}</span> queued ICE candidates for <span class="hljs-subst">${peerId}</span>. Remote desc type: <span class="hljs-subst">${pc.remoteDescription.<span class="hljs-keyword">type</span>}</span>, Signaling state: <span class="hljs-subst">${pc.signalingState}</span>`</span>);
      <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">const</span> candidate = queue.shift(); <span class="hljs-comment">// Get the oldest candidate</span>
        <span class="hljs-keyword">if</span> (candidate) {
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> pc.addIceCandidate(candidate);
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Successfully added queued ICE candidate for <span class="hljs-subst">${peerId}</span>:`</span>, candidate.candidate.substring(<span class="hljs-number">0</span>, <span class="hljs-number">30</span>) + <span class="hljs-string">&quot;...&quot;</span>); <span class="hljs-comment">// Log partial candidate</span>
          } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-comment">// Common error: Trying to add candidate before remote description is fully stable or in wrong state.</span>
            <span class="hljs-comment">// We might retry or log, depending on the specific error.</span>
            <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`Error adding queued ICE candidate for <span class="hljs-subst">${peerId}</span> (State: <span class="hljs-subst">${pc.signalingState}</span>):`</span>, error);
            <span class="hljs-comment">// Optional: Put candidate back in front of queue if it&#x27;s a state issue? Be careful with loops.</span>
            <span class="hljs-comment">// queue.unshift(candidate);</span>
          }
        }
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (queue &amp;&amp; queue.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// Log why we are *not* processing if the queue isn&#x27;t empty</span>
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Not processing queued ICE candidates for <span class="hljs-subst">${peerId}</span>. Conditions not met: PC exists=<span class="hljs-subst">${!!pc}</span>, Remote desc set=<span class="hljs-subst">${!!pc?.remoteDescription}</span>, Queue size=<span class="hljs-subst">${queue?.length}</span>. State: <span class="hljs-subst">${pc?.signalingState}</span>`</span>);
    }
    <span class="hljs-comment">// Clear the queue if it exists, regardless of processing, to prevent reprocessing old candidates if conditions change later</span>
    <span class="hljs-comment">// delete queuedIceCandidatesRef.current[peerId]; // Reconsider if clearing is always right here.</span>
  }, []); <span class="hljs-comment">// No dependencies needed as it uses refs</span>

  <span class="hljs-comment">// --- Initiate Connections to New Peers ---</span>
  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!localStream || isAuthLoading || !isAuthenticated) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Skipping peer connection initiation: Local stream or auth not ready.&quot;</span>);
      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Don&#x27;t proceed if local stream or auth isn&#x27;t ready</span>
    }

    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Checking for new peers to connect to...&quot;</span>, otherParticipantIds);

    otherParticipantIds.forEach(<span class="hljs-function"><span class="hljs-params">peerId</span> =&gt;</span> {
      <span class="hljs-comment">// Check if a connection already exists or is being established</span>
      <span class="hljs-keyword">if</span> (!peerConnections.current[peerId]) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Initiating connection to new peer: <span class="hljs-subst">${peerId}</span>`</span>);

        <span class="hljs-comment">// 1. Create Peer Connection</span>
        <span class="hljs-keyword">const</span> pc = createPeerConnection(peerId);
        <span class="hljs-keyword">if</span> (!pc) {
          <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`Failed to create peer connection for <span class="hljs-subst">${peerId}</span>`</span>);
          <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Skip if creation failed</span>
        }

        <span class="hljs-comment">// Note: Offer creation is now primarily handled by onnegotiationneeded</span>
        <span class="hljs-comment">// triggered by adding tracks in createPeerConnection. We might not need</span>
        <span class="hljs-comment">// to explicitly create/send an offer here anymore, unless onnegotiationneeded</span>
        <span class="hljs-comment">// doesn&#x27;t fire reliably in all browsers/scenarios.</span>
        <span class="hljs-comment">// Let&#x27;s keep the explicit offer sending for now as a fallback, but guard it.</span>
        <span class="hljs-keyword">if</span> (pc.signalingState === <span class="hljs-string">&#x27;stable&#x27;</span> &amp;&amp; !makingOffer.current[peerId] &amp;&amp; !ignoreOffer.current[peerId]){
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Attempting initial offer to new peer: <span class="hljs-subst">${peerId}</span> (fallback)`</span>);
             makingOffer.current[peerId] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Set flag</span>
            pc.createOffer()
                .then(<span class="hljs-function"><span class="hljs-params">offer</span> =&gt;</span> {
                    <span class="hljs-comment">// Check state again before setting local description</span>
                     <span class="hljs-keyword">if</span> (pc.signalingState !== <span class="hljs-string">&#x27;stable&#x27;</span>) {
                        <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`State changed before setting initial offer for <span class="hljs-subst">${peerId}</span>. Aborting.`</span>);
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Signaling state not stable: <span class="hljs-subst">${pc.signalingState}</span>`</span>);
                     }
                    <span class="hljs-keyword">return</span> pc.setLocalDescription(offer);
                })
                .then(<span class="hljs-function">() =&gt;</span> {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Initial local description (offer) set for <span class="hljs-subst">${peerId}</span>`</span>);
                <span class="hljs-keyword">if</span> (pc.localDescription) {
                    sendSignal({
                    sessionId,
                    <span class="hljs-attr">targetUserId</span>: peerId,
                    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;offer&quot;</span>,
                    <span class="hljs-attr">signal</span>: <span class="hljs-built_in">JSON</span>.stringify({ <span class="hljs-attr">type</span>: pc.localDescription.type, <span class="hljs-attr">sdp</span>: pc.localDescription.sdp }),
                    });
                }
                })
                .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
                    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`Error creating/sending initial offer to <span class="hljs-subst">${peerId}</span>:`</span>, error);
                     <span class="hljs-comment">// Clean up potentially inconsistent state</span>
                     <span class="hljs-keyword">delete</span> peerConnections.current[peerId];
                     pc.close();
                })
                 .finally(<span class="hljs-function">() =&gt;</span> {
                    <span class="hljs-comment">// Reset flag if not ignored</span>
                    <span class="hljs-keyword">if</span> (!ignoreOffer.current[peerId]) {
                         makingOffer.current[peerId] = <span class="hljs-literal">false</span>;
                    }
                 });
        } <span class="hljs-keyword">else</span> {
             <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Skipping initial offer for <span class="hljs-subst">${peerId}</span>: state=<span class="hljs-subst">${pc.signalingState}</span>, making=<span class="hljs-subst">${makingOffer.current[peerId]}</span>, ignore=<span class="hljs-subst">${ignoreOffer.current[peerId]}</span>`</span>);
        }
      } <span class="hljs-keyword">else</span> {
         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Connection status for existing peer <span class="hljs-subst">${peerId}</span>: <span class="hljs-subst">${peerConnections.current[peerId]?.connectionState}</span>`</span>);
         <span class="hljs-comment">// Optional: Add logic here to re-initiate if connection failed previously</span>
      }
    });

    <span class="hljs-comment">// Optional: Clean up connections for peers who left</span>
    <span class="hljs-comment">// Get current peer IDs from state</span>
    <span class="hljs-keyword">const</span> currentPeerIds = <span class="hljs-built_in">Object</span>.keys(peerConnections.current);
    currentPeerIds.forEach(<span class="hljs-function"><span class="hljs-params">peerId</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (!otherParticipantIds.includes(peerId)) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Cleaning up connection for left peer: <span class="hljs-subst">${peerId}</span>`</span>);
        peerConnections.current[peerId]?.close();
        <span class="hljs-keyword">delete</span> peerConnections.current[peerId]; <span class="hljs-comment">// Use delete instead of assigning undefined</span>
      }
    });

  <span class="hljs-comment">// Dependencies: Run when participant list, local stream, or auth state changes</span>
  <span class="hljs-comment">// Added peerConnections to re-evaluate state, but be cautious of loops</span>
  }, [otherParticipantIds, localStream, isAuthLoading, isAuthenticated, createPeerConnection, sendSignal, sessionId]);

  <span class="hljs-comment">// --- Process Incoming Signals ---</span>
  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (isAuthLoading || !isAuthenticated || !signals) {
      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Don&#x27;t process signals if auth is loading or not authenticated</span>
    }

    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Received signals:&quot;</span>, signals);

    signals?.forEach(<span class="hljs-keyword">async</span> (signal) =&gt; {
      <span class="hljs-comment">// Correct destructuring: Use userId and alias it as senderId</span>
      <span class="hljs-keyword">const</span> { <span class="hljs-attr">userId</span>: senderId, <span class="hljs-keyword">type</span>, <span class="hljs-attr">signal</span>: signalData } = signal;

      <span class="hljs-comment">// Don&#x27;t process signals from self</span>
      <span class="hljs-keyword">if</span> (senderId === userId) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Compare aliased senderId with component&#x27;s userId</span>

      <span class="hljs-comment">// Ensure peer connection exists</span>
      <span class="hljs-keyword">const</span> peerData = peerConnections.current[senderId];
      <span class="hljs-keyword">let</span> pc: RTCPeerConnection | <span class="hljs-literal">null</span> = peerData ? peerData : <span class="hljs-literal">null</span>;

      <span class="hljs-comment">// If connection doesn&#x27;t exist for an incoming signal (e.g., offer), create it.</span>
      <span class="hljs-keyword">if</span> (!pc &amp;&amp; <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;offer&#x27;</span>) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Signal received from new peer <span class="hljs-subst">${senderId}</span>. Creating connection.`</span>);
        <span class="hljs-keyword">const</span> createdPc = createPeerConnection(senderId); <span class="hljs-comment">// Returns RTCPeerConnection | null</span>
        <span class="hljs-keyword">if</span> (createdPc) { <span class="hljs-comment">// Check ensures createdPc is not null here</span>
            <span class="hljs-comment">// Update state *inside* the check where createdPc is known to be non-null</span>
            peerConnections.current[senderId] = createdPc; <span class="hljs-comment">// Explicitly assign non-null connection</span>
            pc = createdPc; <span class="hljs-comment">// Assign the non-null connection to the loop variable &#x27;pc&#x27;</span>
        } <span class="hljs-keyword">else</span> {
             <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`Failed to create peer connection for signal from <span class="hljs-subst">${senderId}</span>`</span>);
             <span class="hljs-comment">// pc remains null, subsequent check will handle this</span>
        }
      }

      <span class="hljs-comment">// Check if pc is still null after potential creation attempt</span>
      <span class="hljs-keyword">if</span> (!pc) {
        <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`No peer connection found for signal from <span class="hljs-subst">${senderId}</span>. Signal type: <span class="hljs-subst">${<span class="hljs-keyword">type</span>}</span>. Ignoring.`</span>);
        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Exit if no valid connection</span>
      }

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> parsedData = <span class="hljs-built_in">JSON</span>.parse(signalData);

        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">type</span>) {
          <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;offer&quot;</span>:
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Received offer from: <span class="hljs-subst">${senderId}</span>`</span>);
            <span class="hljs-keyword">const</span> offerDescription = <span class="hljs-keyword">new</span> RTCSessionDescription(parsedData);

            <span class="hljs-comment">// Perfect negotiation: Check makingOffer/ignoreOffer flags and signaling state</span>
            <span class="hljs-keyword">const</span> isMakingOffer = makingOffer.current[senderId];
            <span class="hljs-keyword">const</span> polite = userId! &gt; senderId; <span class="hljs-comment">// Determine politeness based on user ID comparison</span>
            <span class="hljs-keyword">const</span> ignore = ignoreOffer.current[senderId];

            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Offer from <span class="hljs-subst">${senderId}</span>: polite=<span class="hljs-subst">${polite}</span>, makingOffer=<span class="hljs-subst">${isMakingOffer}</span>, ignoreOffer=<span class="hljs-subst">${ignore}</span>, state=<span class="hljs-subst">${pc.signalingState}</span>`</span>);

            <span class="hljs-comment">// Condition 1: If we are making an offer and we are the impolite peer, ignore the incoming offer.</span>
            <span class="hljs-keyword">if</span> (isMakingOffer &amp;&amp; !polite) {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Ignoring offer from <span class="hljs-subst">${senderId}</span> (impolite peer, currently making offer)`</span>);
                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Let our offer proceed</span>
            }

             <span class="hljs-comment">// Condition 2: Set ignore flag if we receive an offer while not stable and we are the polite peer</span>
            <span class="hljs-comment">// This prevents us from processing our own offer if it was created concurrently</span>
            ignoreOffer.current[senderId] = !polite &amp;&amp; pc.signalingState !== <span class="hljs-string">&#x27;stable&#x27;</span>;

            <span class="hljs-comment">// Condition 3: Check signaling state before setting remote description</span>
            <span class="hljs-keyword">if</span> (pc.signalingState !== <span class="hljs-string">&#x27;stable&#x27;</span> &amp;&amp; pc.signalingState !== <span class="hljs-string">&#x27;have-local-offer&#x27;</span>) {
                <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`Received offer from <span class="hljs-subst">${senderId}</span>, but signaling state is <span class="hljs-subst">${pc.signalingState}</span>. Cannot process.`</span>);
                 <span class="hljs-comment">// If state is have-remote-offer, it&#x27;s likely a duplicate, can safely ignore.</span>
                <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-comment">// Handle offer collision (glare) based on politeness</span>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[Glare] Handling offer collision. My ID: <span class="hljs-subst">${userId}</span>, Sender ID: <span class="hljs-subst">${senderId}</span>, Polite: <span class="hljs-subst">${polite}</span>`</span>);
            <span class="hljs-keyword">if</span> (polite) {
                <span class="hljs-comment">// Polite peer rollback: Set remote description, create answer.</span>
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[Glare] Polite peer yielding to offer from <span class="hljs-subst">${senderId}</span>. Setting remote, then answering.`</span>);
                <span class="hljs-keyword">await</span> pc.setRemoteDescription(<span class="hljs-keyword">new</span> RTCSessionDescription({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;offer&#x27;</span>, <span class="hljs-attr">sdp</span>: parsedData.sdp }));
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Remote description (offer) set for <span class="hljs-subst">${senderId}</span>`</span>);

                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Creating answer for <span class="hljs-subst">${senderId}</span>`</span>);
                <span class="hljs-keyword">if</span> (pc.signalingState === <span class="hljs-string">&#x27;have-remote-offer&#x27;</span>) { <span class="hljs-comment">// Check state before creating answer</span>
                    <span class="hljs-keyword">const</span> answer = <span class="hljs-keyword">await</span> pc.createAnswer();
                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Setting local description (answer) for <span class="hljs-subst">${senderId}</span>`</span>);
                    <span class="hljs-keyword">if</span> (pc.signalingState === <span class="hljs-string">&#x27;have-remote-offer&#x27;</span>) { <span class="hljs-comment">// Final check before setting local answer</span>
                        <span class="hljs-keyword">await</span> pc.setLocalDescription(answer);
                        ignoreOffer.current[senderId] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Reset flag</span>
                        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Sending answer to <span class="hljs-subst">${senderId}</span>`</span>);
                        sendSignal({
                            sessionId,
                            <span class="hljs-attr">targetUserId</span>: senderId,
                            <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;answer&quot;</span>,
                            <span class="hljs-attr">signal</span>: <span class="hljs-built_in">JSON</span>.stringify({ <span class="hljs-attr">type</span>: answer.type, <span class="hljs-attr">sdp</span>: answer.sdp }),
                        });
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`[Aborting Answer] State changed to <span class="hljs-subst">${pc.signalingState}</span> just before setting local description (answer) for <span class="hljs-subst">${senderId}</span>.`</span>);
                        ignoreOffer.current[senderId] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Reset flag</span>
                    }
                } <span class="hljs-keyword">else</span> {
                     <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`Tried to create answer for <span class="hljs-subst">${senderId}</span> but signaling state is <span class="hljs-subst">${pc.signalingState}</span> (expected have-remote-offer).`</span>);
                     ignoreOffer.current[senderId] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Reset flag</span>
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// Impolite peer rollback: Ignore the incoming offer for now.</span>
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[Glare] Impolite peer received offer from <span class="hljs-subst">${senderId}</span> while in <span class="hljs-subst">${pc.signalingState}</span>. Ignoring this offer and setting ignoreOffer flag.`</span>);
                ignoreOffer.current[senderId] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Set flag to ignore subsequent offers until this negotiation resolves</span>
                <span class="hljs-comment">// Do NOT process this incoming offer (no setRemoteDescription, no createAnswer)</span>
                <span class="hljs-comment">// Let the negotiation initiated by this impolite peer proceed.</span>
            }
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;answer&quot;</span>:
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Received answer from: <span class="hljs-subst">${senderId}</span>`</span>);
            <span class="hljs-comment">// Recreate RTCSessionDescription from parsed data</span>
            <span class="hljs-keyword">const</span> answerDescription = <span class="hljs-keyword">new</span> RTCSessionDescription(parsedData);
            <span class="hljs-comment">// Set answer only if we are expecting one</span>
            <span class="hljs-keyword">if</span> (pc.signalingState === <span class="hljs-string">&#x27;have-local-offer&#x27;</span>) {
                <span class="hljs-keyword">await</span> pc.setRemoteDescription(answerDescription);
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Remote description (answer) set for <span class="hljs-subst">${senderId}</span>`</span>);

                <span class="hljs-comment">// Process any queued candidates for this peer</span>
                <span class="hljs-keyword">await</span> processQueuedIceCandidates(senderId);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`Received answer from <span class="hljs-subst">${senderId}</span>, but signaling state is <span class="hljs-subst">${pc.signalingState}</span>. Ignoring.`</span>);
            }

            deleteSignal({ <span class="hljs-attr">signalId</span>: signal._id });
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;candidate&quot;</span>:
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Received ICE candidate from: <span class="hljs-subst">${senderId}</span>`</span>);
            <span class="hljs-comment">// Recreate RTCIceCandidate from parsed data</span>
            <span class="hljs-keyword">const</span> iceCandidate = <span class="hljs-keyword">new</span> RTCIceCandidate(parsedData);
            <span class="hljs-comment">// Add candidate only if remote description is set</span>
            <span class="hljs-keyword">if</span> (pc.remoteDescription) {
              <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">await</span> pc.addIceCandidate(iceCandidate);
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Added ICE candidate from <span class="hljs-subst">${senderId}</span>`</span>);
              } <span class="hljs-keyword">catch</span> (addError) {
                <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`Error adding ICE candidate for <span class="hljs-subst">${senderId}</span>:`</span>, addError);
              }
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`Received ICE candidate from <span class="hljs-subst">${senderId}</span>, but remote description not set yet. Queueing.`</span>);
              <span class="hljs-comment">// Queue the candidate if remote description isn&#x27;t set</span>
              <span class="hljs-keyword">if</span> (!queuedIceCandidatesRef.current[senderId]) {
                queuedIceCandidatesRef.current[senderId] = [];
              }
              queuedIceCandidatesRef.current[senderId].push(iceCandidate); <span class="hljs-comment">// Store the candidate directly</span>
            }

            deleteSignal({ <span class="hljs-attr">signalId</span>: signal._id });
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">default</span>:
            <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`Received unknown signal type: <span class="hljs-subst">${<span class="hljs-keyword">type</span>}</span>`</span>);
        }
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`Error processing signal from <span class="hljs-subst">${senderId}</span>:`</span>, signal, error);
      }
    });

    <span class="hljs-comment">// Note: Consider adding logic to clear processed signals from the Convex query if they persist.</span>

  }, [signals, isAuthLoading, isAuthenticated, createPeerConnection, sendSignal, sessionId, userId, deleteSignal, processQueuedIceCandidates]); <span class="hljs-comment">// Added userId dependency</span>

  <span class="hljs-comment">// --- Assign Remote Streams to Video Elements ---</span>
  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">Object</span>.keys(remoteStreams).forEach(<span class="hljs-function">(<span class="hljs-params">peerId</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> stream = remoteStreams[peerId];
      <span class="hljs-keyword">const</span> videoElement = remoteVideoRefs.current[peerId];
      <span class="hljs-keyword">if</span> (videoElement &amp;&amp; stream &amp;&amp; videoElement.srcObject !== stream) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Assigning remote stream from <span class="hljs-subst">${peerId}</span> to video element`</span>);
        videoElement.srcObject = stream;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (videoElement &amp;&amp; !stream) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Clearing stream for <span class="hljs-subst">${peerId}</span>`</span>);
        videoElement.srcObject = <span class="hljs-literal">null</span>;
      }
    });
  }, [remoteStreams]); <span class="hljs-comment">// Re-run when remoteStreams changes</span>


  <span class="hljs-comment">// --- Render Component ---</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.videoCallContainer}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Video Call - {username} ({userId.substring(0, 4)})<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.videoArea}</span>&gt;</span>
        {/* Local Video */}
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.videoWrapper}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">video</span>
            <span class="hljs-attr">ref</span>=<span class="hljs-string">{localVideoRef}</span>
            <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.videoElement}</span>
            <span class="hljs-attr">autoPlay</span>
            <span class="hljs-attr">playsInline</span>
            <span class="hljs-attr">muted</span> // <span class="hljs-attr">Mute</span> <span class="hljs-attr">local</span> <span class="hljs-attr">video</span> <span class="hljs-attr">playback</span> <span class="hljs-attr">to</span> <span class="hljs-attr">avoid</span> <span class="hljs-attr">echo</span>
          /&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>You ({username.substring(0,6)})<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

        {/* Remote Videos */}
        {Object.keys(remoteStreams).map((peerId) =&gt; (
            // Only render if connection exists, even if stream not yet arrived
           peerConnections.current[peerId] &amp;&amp; (
             <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{peerId}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.videoWrapper}</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">video</span>
                    <span class="hljs-attr">ref</span>=<span class="hljs-string">{(el)</span> =&gt;</span> (remoteVideoRefs.current[peerId] = el)} // Assign ref
                    className={styles.videoElement}
                    autoPlay
                    playsInline
                /&gt;
                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Peer: {peerId.substring(0, 4)} {peerConnections.current[peerId].connectionState}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
                 {/* TODO: Get actual username for peerId */}
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
           )
        ))} 
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.controls}</span>&gt;</span>
        {/* TODO: Add call controls (mute audio, disable video, hang up) */}
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> console.log(&quot;Peer Connections:&quot;, peerConnections.current)}&gt;Log Peers<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> console.log(&quot;Signals:&quot;, signals)}&gt;Log Signals<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

</code></pre>
<h4 id=src\contexts\AuthContexttsx anchor=true>src\contexts\AuthContexttsx</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { createContext, useContext, useState, useEffect, ReactNode } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { useNavigate } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;
<span class="hljs-keyword">import</span> { useClerk, useUser } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@clerk/clerk-react&quot;</span>;

<span class="hljs-keyword">interface</span> AuthContextType {
  <span class="hljs-attr">userId</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
  username: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
  login: <span class="hljs-function">(<span class="hljs-params">userId: <span class="hljs-built_in">string</span>, username: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  logout: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
  isAuthenticated: <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-comment">// Create the context with a default value</span>
<span class="hljs-keyword">const</span> AuthContext = createContext&lt;AuthContextType | <span class="hljs-literal">undefined</span>&gt;(<span class="hljs-literal">undefined</span>);

<span class="hljs-comment">// Provider component</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AuthProvider</span>(<span class="hljs-params">{ children }: { children: ReactNode }</span>) </span>{
  <span class="hljs-keyword">const</span> navigate = useNavigate();
  <span class="hljs-keyword">const</span> [userId, setUserId] = useState&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&quot;userId&quot;</span>));
  <span class="hljs-keyword">const</span> [username, setUsername] = useState&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&quot;username&quot;</span>));
  <span class="hljs-keyword">const</span> clerk = useClerk();
  <span class="hljs-keyword">const</span> { isSignedIn, <span class="hljs-attr">isLoaded</span>: clerkLoaded, user } = useUser();

  <span class="hljs-comment">// Consider both local auth and Clerk auth for determining authenticated state</span>
  <span class="hljs-keyword">const</span> isAuthenticated = (!!userId &amp;&amp; !!username) || (clerkLoaded &amp;&amp; isSignedIn);

  <span class="hljs-comment">// Listen for Clerk authentication changes</span>
  useEffect(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> checkClerkAuth = <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-comment">// Only proceed if Clerk is loaded</span>
      <span class="hljs-keyword">if</span> (!clerkLoaded) <span class="hljs-keyword">return</span>;
      
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Clerk auth state:&quot;</span>, { isSignedIn, clerkLoaded });
      
      <span class="hljs-comment">// If signed in with Clerk</span>
      <span class="hljs-keyword">if</span> (isSignedIn &amp;&amp; user) {
        <span class="hljs-comment">// First check if we already have local auth data</span>
        <span class="hljs-keyword">const</span> storedUserId = <span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&quot;userId&quot;</span>);
        <span class="hljs-keyword">const</span> storedUsername = <span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&quot;username&quot;</span>);

        <span class="hljs-comment">// Derive potential new values from Clerk</span>
        <span class="hljs-keyword">const</span> clerkUserId = user.id;
        <span class="hljs-keyword">const</span> clerkUsername = user.username || 
                              (user.firstName &amp;&amp; user.lastName ? 
                                <span class="hljs-string">`<span class="hljs-subst">${user.firstName}</span> <span class="hljs-subst">${user.lastName}</span>`</span> : 
                                user.emailAddresses?.[<span class="hljs-number">0</span>]?.emailAddress || <span class="hljs-string">&#x27;user&#x27;</span>);
        
        <span class="hljs-comment">// Check if local storage exists AND matches current state. If not, update state from local storage.</span>
        <span class="hljs-keyword">if</span> (storedUserId &amp;&amp; storedUsername &amp;&amp; (storedUserId !== userId || storedUsername !== username)) {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Restoring/updating local auth state from storage&quot;</span>);
          setUserId(storedUserId);
          setUsername(storedUsername);
        }
        <span class="hljs-comment">// If no local storage OR Clerk data is different from current state, update from Clerk.</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!storedUserId || !storedUsername || clerkUserId !== userId || clerkUsername !== username) {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Using Clerk user information to update state&quot;</span>);
          <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&quot;userId&quot;</span>, clerkUserId);
          <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&quot;username&quot;</span>, clerkUsername);
          <span class="hljs-comment">// Only update state if it&#x27;s actually different</span>
          <span class="hljs-keyword">if</span> (clerkUserId !== userId) setUserId(clerkUserId);
          <span class="hljs-keyword">if</span> (clerkUsername !== username) setUsername(clerkUsername);
        }
        <span class="hljs-comment">// If Clerk is signed in but state already matches, do nothing</span>
        
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isSignedIn &amp;&amp; (userId || username)) {
          <span class="hljs-comment">// Handle case where Clerk signs out but local state still exists (optional)</span>
          <span class="hljs-comment">// The logout function already handles clearing state, so maybe just log here.</span>
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Clerk signed out, local state might still exist.&quot;</span>);
      }
    };
    
    checkClerkAuth();
  }, [isSignedIn, clerkLoaded, user]);

  <span class="hljs-keyword">const</span> login = <span class="hljs-function">(<span class="hljs-params">newUserId: <span class="hljs-built_in">string</span>, newUsername: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Login called with&quot;</span>, { newUserId, newUsername });
    <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&quot;userId&quot;</span>, newUserId);
    <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&quot;username&quot;</span>, newUsername);
    setUserId(newUserId);
    setUsername(newUsername);
    navigate(<span class="hljs-string">&quot;/&quot;</span>);
  };

  <span class="hljs-keyword">const</span> logout = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// sign out from Clerk if there&#x27;s an active session</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">if</span> (clerk.session) {
        <span class="hljs-keyword">await</span> clerk.signOut();
      }
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Error signing out from Clerk:&quot;</span>, error);
    }
    
    <span class="hljs-comment">// Clear local auth state</span>
    <span class="hljs-built_in">localStorage</span>.removeItem(<span class="hljs-string">&quot;userId&quot;</span>);
    <span class="hljs-built_in">localStorage</span>.removeItem(<span class="hljs-string">&quot;username&quot;</span>);
    setUserId(<span class="hljs-literal">null</span>);
    setUsername(<span class="hljs-literal">null</span>);
    
    navigate(<span class="hljs-string">&quot;/login&quot;</span>);
  };

  <span class="hljs-comment">// Value to be provided to consumers</span>
  <span class="hljs-keyword">const</span> value = {
    userId,
    username,
    login,
    logout,
    isAuthenticated
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AuthContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span>&gt;</span>
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">AuthContext.Provider</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// Hook for components to use the auth context</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useAuth</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> context = useContext(AuthContext);
  <span class="hljs-keyword">if</span> (context === <span class="hljs-literal">undefined</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;useAuth must be used within an AuthProvider&quot;</span>);
  }
  <span class="hljs-keyword">return</span> context;
} 
</code></pre>
<h4 id=src\convexts anchor=true>src\convexts</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { useQuery, useMutation, useAction } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/react&quot;</span>;
<span class="hljs-keyword">import</span> { api } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../convex/_generated/api&quot;</span>;

<span class="hljs-keyword">export</span> { useQuery, useMutation, useAction, api };

</code></pre>
<h4 id=src\maintsx anchor=true>src\maintsx</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { StrictMode } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/client&quot;</span>;
<span class="hljs-keyword">import</span> { BrowserRouter, Routes, Route } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./index.css&quot;</span>;
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App&quot;</span>;
<span class="hljs-keyword">import</span> { ConvexReactClient } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/react&quot;</span>;
<span class="hljs-keyword">import</span> { ConvexProviderWithClerk } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;convex/react-clerk&quot;</span>; 
<span class="hljs-keyword">import</span> { ClerkProvider, useAuth } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@clerk/clerk-react&quot;</span>;
<span class="hljs-keyword">import</span> { Toaster } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-hot-toast&quot;</span>;

<span class="hljs-keyword">const</span> convex = <span class="hljs-keyword">new</span> ConvexReactClient(<span class="hljs-keyword">import</span>.meta.env.VITE_CONVEX_URL);
<span class="hljs-keyword">const</span> clerkPubKey = <span class="hljs-keyword">import</span>.meta.env.VITE_CLERK_PUBLISHABLE_KEY;

ReactDOM.createRoot(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;root&quot;</span>)!).render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">StrictMode</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ClerkProvider</span> 
      <span class="hljs-attr">publishableKey</span>=<span class="hljs-string">{clerkPubKey}</span>
      <span class="hljs-attr">afterSignInUrl</span>=<span class="hljs-string">&quot;/oauth-callback&quot;</span>
      <span class="hljs-attr">afterSignUpUrl</span>=<span class="hljs-string">&quot;/oauth-callback&quot;</span>
      <span class="hljs-attr">signInUrl</span>=<span class="hljs-string">&quot;/login&quot;</span>
      <span class="hljs-attr">signUpUrl</span>=<span class="hljs-string">&quot;/register&quot;</span>
    &gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ConvexProviderWithClerk</span> <span class="hljs-attr">client</span>=<span class="hljs-string">{convex}</span> <span class="hljs-attr">useAuth</span>=<span class="hljs-string">{useAuth}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Toaster</span>
            <span class="hljs-attr">position</span>=<span class="hljs-string">&quot;bottom-right&quot;</span>
            <span class="hljs-attr">toastOptions</span>=<span class="hljs-string">{{</span>
              <span class="hljs-attr">duration:</span> <span class="hljs-attr">4000</span>,
              <span class="hljs-attr">style:</span> {
                <span class="hljs-attr">background:</span> &#x27;#<span class="hljs-attr">333</span>&#x27;,
                <span class="hljs-attr">color:</span> &#x27;#<span class="hljs-attr">fff</span>&#x27;,
              },
              <span class="hljs-attr">success:</span> {
                <span class="hljs-attr">style:</span> {
                  <span class="hljs-attr">background:</span> &#x27;#<span class="hljs-attr">10b981</span>&#x27;,
                },
              },
              <span class="hljs-attr">error:</span> {
                <span class="hljs-attr">style:</span> {
                  <span class="hljs-attr">background:</span> &#x27;#<span class="hljs-attr">ef4444</span>&#x27;,
                },
              },
            }}
          /&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/*&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">App</span> /&gt;</span>} /&gt;
          <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">ConvexProviderWithClerk</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ClerkProvider</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">StrictMode</span>&gt;</span></span>,
);

</code></pre>
<h4 id=src\utils\toastts anchor=true>src\utils\toastts</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-keyword">import</span> toast <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-hot-toast&#x27;</span>;

<span class="hljs-comment">// Define toast notification types</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> showToast = {
  <span class="hljs-comment">/**
   * Show a success toast notification
   */</span>
  <span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
    toast.success(message, {
      <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;🎉&#x27;</span>,
    });
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Success: <span class="hljs-subst">${message}</span>`</span>); <span class="hljs-comment">// For debugging</span>
  },

  <span class="hljs-comment">/**
   * Show an error toast notification
   */</span>
  <span class="hljs-attr">error</span>: <span class="hljs-function">(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
    toast.error(message, {
      <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;❌&#x27;</span>,
    });
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`Error: <span class="hljs-subst">${message}</span>`</span>); <span class="hljs-comment">// For debugging</span>
  },

  <span class="hljs-comment">/**
   * Show an informational toast notification
   */</span>
  <span class="hljs-attr">info</span>: <span class="hljs-function">(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
    toast(message, {
      <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;ℹ️&#x27;</span>,
    });
    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">`Info: <span class="hljs-subst">${message}</span>`</span>); <span class="hljs-comment">// For debugging</span>
  },

  <span class="hljs-comment">/**
   * Show a warning toast notification
   */</span>
  <span class="hljs-attr">warning</span>: <span class="hljs-function">(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
    toast(message, {
      <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;⚠️&#x27;</span>,
      <span class="hljs-attr">style</span>: {
        <span class="hljs-attr">background</span>: <span class="hljs-string">&#x27;#f59e0b&#x27;</span>,
        <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#fff&#x27;</span>,
      },
    });
    <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`Warning: <span class="hljs-subst">${message}</span>`</span>); <span class="hljs-comment">// For debugging</span>
  },

  <span class="hljs-comment">/**
   * Show a toast notification for session events
   */</span>
  <span class="hljs-attr">session</span>: {
    <span class="hljs-attr">created</span>: <span class="hljs-function">() =&gt;</span> showToast.success(<span class="hljs-string">&#x27;Session created successfully!&#x27;</span>),
    <span class="hljs-attr">updated</span>: <span class="hljs-function">() =&gt;</span> showToast.success(<span class="hljs-string">&#x27;Session updated successfully!&#x27;</span>),
    <span class="hljs-attr">deleted</span>: <span class="hljs-function">() =&gt;</span> showToast.success(<span class="hljs-string">&#x27;Session deleted successfully!&#x27;</span>),
    <span class="hljs-attr">pastDateError</span>: <span class="hljs-function">() =&gt;</span> showToast.error(<span class="hljs-string">&#x27;Cannot create session in the past. Please select a future date.&#x27;</span>),
    <span class="hljs-attr">overlapError</span>: <span class="hljs-function">() =&gt;</span> showToast.error(<span class="hljs-string">&#x27;Cannot create overlapping sessions. You already have a session scheduled during this time.&#x27;</span>),
    <span class="hljs-attr">joined</span>: <span class="hljs-function">() =&gt;</span> showToast.success(<span class="hljs-string">&#x27;Joined session successfully!&#x27;</span>),
    <span class="hljs-attr">earlyJoin</span>: <span class="hljs-function">(<span class="hljs-params">minutesEarly: <span class="hljs-built_in">number</span></span>) =&gt;</span> showToast.info(<span class="hljs-string">`You&#x27;ve joined the session <span class="hljs-subst">${minutesEarly}</span> minutes early!`</span>),
  }
}; 
</code></pre>
<h4 id=src\vite-envd.ts anchor=true>src\vite-envd.ts</h4>
<p><a href="#Contents">to top</a></p>
<pre><code class="language-typescript"><span class="hljs-comment">/// &lt;reference types=&quot;vite/client&quot; /&gt;</span>

</code></pre>
</article>

            
        <script src="file://C:\Users\micha\AppData\Local\npm-cache\_npx\51def3eb5b6cdb1a\node_modules\repo-to-pdf\html5bp/js/vendor/jquery-1.10.2.min.js"></script>
        <script src="file://C:\Users\micha\AppData\Local\npm-cache\_npx\51def3eb5b6cdb1a\node_modules\repo-to-pdf\html5bp/js/plugins.js"></script>
        <script src="file://C:\Users\micha\AppData\Local\npm-cache\_npx\51def3eb5b6cdb1a\node_modules\repo-to-pdf\html5bp/js/main.js"></script>
    </body>
</html>
